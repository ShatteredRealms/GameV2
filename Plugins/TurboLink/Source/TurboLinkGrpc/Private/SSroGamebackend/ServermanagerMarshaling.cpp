//Generated by TurboLink CodeGenerator, do not edit!
#include "ServermanagerMarshaling.h"
#include "SGoogleApi/AnnotationsMarshaling.h"
#include "SGoogleProtobuf/EmptyMarshaling.h"

void GRPC_TO_TURBOLINK(const ::sro::gamebackend::DimensionTarget* in, FGrpcSroGamebackendDimensionTarget* out)
{
    switch(in->FindBy_case())
    {
    case ::sro::gamebackend::DimensionTarget::kId:
        out->FindBy.Id=UTF8_TO_TCHAR(in->id().c_str());
        out->FindBy.FindByCase = EGrpcSroGamebackendDimensionTargetFindBy::Id;
        break;
    case ::sro::gamebackend::DimensionTarget::kName:
        out->FindBy.Name=UTF8_TO_TCHAR(in->name().c_str());
        out->FindBy.FindByCase = EGrpcSroGamebackendDimensionTargetFindBy::Name;
        break;
    }
}

void TURBOLINK_TO_GRPC(const FGrpcSroGamebackendDimensionTarget* in, ::sro::gamebackend::DimensionTarget* out)
{
    switch (in->FindBy.FindByCase)
    {
    case EGrpcSroGamebackendDimensionTargetFindBy::Id:
        out->set_id(TCHAR_TO_UTF8(*(in->FindBy.Id)));
        break;
    case EGrpcSroGamebackendDimensionTargetFindBy::Name:
        out->set_name(TCHAR_TO_UTF8(*(in->FindBy.Name)));
        break;
    }
}

void GRPC_TO_TURBOLINK(const ::sro::gamebackend::MapTarget* in, FGrpcSroGamebackendMapTarget* out)
{
    switch(in->FindBy_case())
    {
    case ::sro::gamebackend::MapTarget::kId:
        out->FindBy.Id=UTF8_TO_TCHAR(in->id().c_str());
        out->FindBy.FindByCase = EGrpcSroGamebackendMapTargetFindBy::Id;
        break;
    case ::sro::gamebackend::MapTarget::kName:
        out->FindBy.Name=UTF8_TO_TCHAR(in->name().c_str());
        out->FindBy.FindByCase = EGrpcSroGamebackendMapTargetFindBy::Name;
        break;
    }
}

void TURBOLINK_TO_GRPC(const FGrpcSroGamebackendMapTarget* in, ::sro::gamebackend::MapTarget* out)
{
    switch (in->FindBy.FindByCase)
    {
    case EGrpcSroGamebackendMapTargetFindBy::Id:
        out->set_id(TCHAR_TO_UTF8(*(in->FindBy.Id)));
        break;
    case EGrpcSroGamebackendMapTargetFindBy::Name:
        out->set_name(TCHAR_TO_UTF8(*(in->FindBy.Name)));
        break;
    }
}

void GRPC_TO_TURBOLINK(const ::sro::gamebackend::CreateDimensionRequest* in, FGrpcSroGamebackendCreateDimensionRequest* out)
{
    out->Name=UTF8_TO_TCHAR(in->name().c_str());
    out->Version=UTF8_TO_TCHAR(in->version().c_str());
    out->MapIds.Empty();
    for (int i=0; i<in->map_ids_size(); ++i) {
        out->MapIds.Add(UTF8_TO_TCHAR(in->map_ids(i).c_str()));
    }
    out->Location=UTF8_TO_TCHAR(in->location().c_str());
}

void TURBOLINK_TO_GRPC(const FGrpcSroGamebackendCreateDimensionRequest* in, ::sro::gamebackend::CreateDimensionRequest* out)
{
    out->set_name(TCHAR_TO_UTF8(*(in->Name)));
    out->set_version(TCHAR_TO_UTF8(*(in->Version)));
    for(const auto& value : in->MapIds) {
        out->add_map_ids(TCHAR_TO_UTF8(*(value)));
    } 
    out->set_location(TCHAR_TO_UTF8(*(in->Location)));
}

void GRPC_TO_TURBOLINK(const ::sro::gamebackend::DuplicateDimensionRequest* in, FGrpcSroGamebackendDuplicateDimensionRequest* out)
{
    GRPC_TO_TURBOLINK(&(in->target()), &(out->Target));
    out->Name=UTF8_TO_TCHAR(in->name().c_str());
}

void TURBOLINK_TO_GRPC(const FGrpcSroGamebackendDuplicateDimensionRequest* in, ::sro::gamebackend::DuplicateDimensionRequest* out)
{
    TURBOLINK_TO_GRPC(&(in->Target), out->mutable_target());
    out->set_name(TCHAR_TO_UTF8(*(in->Name)));
}

void GRPC_TO_TURBOLINK(const ::sro::gamebackend::EditDimensionRequest* in, FGrpcSroGamebackendEditDimensionRequest* out)
{
    GRPC_TO_TURBOLINK(&(in->target()), &(out->Target));
    switch(in->optional_name_case())
    {
    case ::sro::gamebackend::EditDimensionRequest::kName:
        out->Optional_name.Name=UTF8_TO_TCHAR(in->name().c_str());
        out->Optional_name.Optional_nameCase = EGrpcSroGamebackendEditDimensionRequestOptional_name::Name;
        break;
    }
    switch(in->optional_version_case())
    {
    case ::sro::gamebackend::EditDimensionRequest::kVersion:
        out->Optional_version.Version=UTF8_TO_TCHAR(in->version().c_str());
        out->Optional_version.Optional_versionCase = EGrpcSroGamebackendEditDimensionRequestOptional_version::Version;
        break;
    }
    out->EditMaps=in->edit_maps();
    out->MapIds.Empty();
    for (int i=0; i<in->map_ids_size(); ++i) {
        out->MapIds.Add(UTF8_TO_TCHAR(in->map_ids(i).c_str()));
    }
    switch(in->optional_location_case())
    {
    case ::sro::gamebackend::EditDimensionRequest::kLocation:
        out->Optional_location.Location=UTF8_TO_TCHAR(in->location().c_str());
        out->Optional_location.Optional_locationCase = EGrpcSroGamebackendEditDimensionRequestOptional_location::Location;
        break;
    }
}

void TURBOLINK_TO_GRPC(const FGrpcSroGamebackendEditDimensionRequest* in, ::sro::gamebackend::EditDimensionRequest* out)
{
    TURBOLINK_TO_GRPC(&(in->Target), out->mutable_target());
    switch (in->Optional_name.Optional_nameCase)
    {
    case EGrpcSroGamebackendEditDimensionRequestOptional_name::Name:
        out->set_name(TCHAR_TO_UTF8(*(in->Optional_name.Name)));
        break;
    }
    switch (in->Optional_version.Optional_versionCase)
    {
    case EGrpcSroGamebackendEditDimensionRequestOptional_version::Version:
        out->set_version(TCHAR_TO_UTF8(*(in->Optional_version.Version)));
        break;
    }
    out->set_edit_maps(in->EditMaps);
    for(const auto& value : in->MapIds) {
        out->add_map_ids(TCHAR_TO_UTF8(*(value)));
    } 
    switch (in->Optional_location.Optional_locationCase)
    {
    case EGrpcSroGamebackendEditDimensionRequestOptional_location::Location:
        out->set_location(TCHAR_TO_UTF8(*(in->Optional_location.Location)));
        break;
    }
}

void GRPC_TO_TURBOLINK(const ::sro::gamebackend::Dimension* in, FGrpcSroGamebackendDimension* out)
{
    out->Id=UTF8_TO_TCHAR(in->id().c_str());
    out->Name=UTF8_TO_TCHAR(in->name().c_str());
    out->Version=UTF8_TO_TCHAR(in->version().c_str());
    out->Maps.Empty();
    for (int i=0; i<in->maps_size(); ++i) {
        FGrpcSroGamebackendMap field;
        GRPC_TO_TURBOLINK(&(in->maps(i)), &field);
        out->Maps.Add(MakeShareable(new FGrpcSroGamebackendMap(field)));
    }
    out->Location=UTF8_TO_TCHAR(in->location().c_str());
}

void TURBOLINK_TO_GRPC(const FGrpcSroGamebackendDimension* in, ::sro::gamebackend::Dimension* out)
{
    out->set_id(TCHAR_TO_UTF8(*(in->Id)));
    out->set_name(TCHAR_TO_UTF8(*(in->Name)));
    out->set_version(TCHAR_TO_UTF8(*(in->Version)));
    for(const auto& value : in->Maps) {
        TURBOLINK_TO_GRPC(value.Get(), out->add_maps());
    } 
    out->set_location(TCHAR_TO_UTF8(*(in->Location)));
}

void GRPC_TO_TURBOLINK(const ::sro::gamebackend::Dimensions* in, FGrpcSroGamebackendDimensions* out)
{
    out->Dimensions.Empty();
    for (int i=0; i<in->dimensions_size(); ++i) {
        GRPC_TO_TURBOLINK(&(in->dimensions(i)), &(out->Dimensions.AddZeroed_GetRef()));
    }
}

void TURBOLINK_TO_GRPC(const FGrpcSroGamebackendDimensions* in, ::sro::gamebackend::Dimensions* out)
{
    for(const auto& value : in->Dimensions) {
        TURBOLINK_TO_GRPC(&value, out->add_dimensions());
    } 
}

void GRPC_TO_TURBOLINK(const ::sro::gamebackend::CreateMapRequest* in, FGrpcSroGamebackendCreateMapRequest* out)
{
    out->Name=UTF8_TO_TCHAR(in->name().c_str());
    out->Path=UTF8_TO_TCHAR(in->path().c_str());
    out->MaxPlayers=in->max_players();
    out->Instanced=in->instanced();
}

void TURBOLINK_TO_GRPC(const FGrpcSroGamebackendCreateMapRequest* in, ::sro::gamebackend::CreateMapRequest* out)
{
    out->set_name(TCHAR_TO_UTF8(*(in->Name)));
    out->set_path(TCHAR_TO_UTF8(*(in->Path)));
    out->set_max_players(in->MaxPlayers);
    out->set_instanced(in->Instanced);
}

void GRPC_TO_TURBOLINK(const ::sro::gamebackend::Map* in, FGrpcSroGamebackendMap* out)
{
    out->Id=UTF8_TO_TCHAR(in->id().c_str());
    out->Name=UTF8_TO_TCHAR(in->name().c_str());
    out->Path=UTF8_TO_TCHAR(in->path().c_str());
    out->MaxPlayers=in->max_players();
    out->Instanced=in->instanced();
}

void TURBOLINK_TO_GRPC(const FGrpcSroGamebackendMap* in, ::sro::gamebackend::Map* out)
{
    out->set_id(TCHAR_TO_UTF8(*(in->Id)));
    out->set_name(TCHAR_TO_UTF8(*(in->Name)));
    out->set_path(TCHAR_TO_UTF8(*(in->Path)));
    out->set_max_players(in->MaxPlayers);
    out->set_instanced(in->Instanced);
}

void GRPC_TO_TURBOLINK(const ::sro::gamebackend::EditMapRequest* in, FGrpcSroGamebackendEditMapRequest* out)
{
    GRPC_TO_TURBOLINK(&(in->target()), &(out->Target));
    switch(in->optional_name_case())
    {
    case ::sro::gamebackend::EditMapRequest::kName:
        out->Optional_name.Name=UTF8_TO_TCHAR(in->name().c_str());
        out->Optional_name.Optional_nameCase = EGrpcSroGamebackendEditMapRequestOptional_name::Name;
        break;
    }
    switch(in->optional_path_case())
    {
    case ::sro::gamebackend::EditMapRequest::kPath:
        out->Optional_path.Path=UTF8_TO_TCHAR(in->path().c_str());
        out->Optional_path.Optional_pathCase = EGrpcSroGamebackendEditMapRequestOptional_path::Path;
        break;
    }
    switch(in->optional_max_players_case())
    {
    case ::sro::gamebackend::EditMapRequest::kMaxPlayers:
        out->Optional_max_players.MaxPlayers=in->max_players();
        out->Optional_max_players.Optional_max_playersCase = EGrpcSroGamebackendEditMapRequestOptional_max_players::MaxPlayers;
        break;
    }
    switch(in->optional_instanced_case())
    {
    case ::sro::gamebackend::EditMapRequest::kInstanced:
        out->Optional_instanced.Instanced=in->instanced();
        out->Optional_instanced.Optional_instancedCase = EGrpcSroGamebackendEditMapRequestOptional_instanced::Instanced;
        break;
    }
}

void TURBOLINK_TO_GRPC(const FGrpcSroGamebackendEditMapRequest* in, ::sro::gamebackend::EditMapRequest* out)
{
    TURBOLINK_TO_GRPC(&(in->Target), out->mutable_target());
    switch (in->Optional_name.Optional_nameCase)
    {
    case EGrpcSroGamebackendEditMapRequestOptional_name::Name:
        out->set_name(TCHAR_TO_UTF8(*(in->Optional_name.Name)));
        break;
    }
    switch (in->Optional_path.Optional_pathCase)
    {
    case EGrpcSroGamebackendEditMapRequestOptional_path::Path:
        out->set_path(TCHAR_TO_UTF8(*(in->Optional_path.Path)));
        break;
    }
    switch (in->Optional_max_players.Optional_max_playersCase)
    {
    case EGrpcSroGamebackendEditMapRequestOptional_max_players::MaxPlayers:
        out->set_max_players(in->Optional_max_players.MaxPlayers);
        break;
    }
    switch (in->Optional_instanced.Optional_instancedCase)
    {
    case EGrpcSroGamebackendEditMapRequestOptional_instanced::Instanced:
        out->set_instanced(in->Optional_instanced.Instanced);
        break;
    }
}

void GRPC_TO_TURBOLINK(const ::sro::gamebackend::Maps* in, FGrpcSroGamebackendMaps* out)
{
    out->Maps.Empty();
    for (int i=0; i<in->maps_size(); ++i) {
        GRPC_TO_TURBOLINK(&(in->maps(i)), &(out->Maps.AddZeroed_GetRef()));
    }
}

void TURBOLINK_TO_GRPC(const FGrpcSroGamebackendMaps* in, ::sro::gamebackend::Maps* out)
{
    for(const auto& value : in->Maps) {
        TURBOLINK_TO_GRPC(&value, out->add_maps());
    } 
}

