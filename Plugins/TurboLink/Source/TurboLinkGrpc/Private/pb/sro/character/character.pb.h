#if defined(_MSC_VER)
  #pragma warning (disable:4946) // reinterpret_cast used between related classes: 'class1' and 'class2'
  #pragma warning (disable:4800) // 'type' : forcing value to bool 'true' or 'false' (performance warning)
  #pragma warning (disable:4582) // 'type': constructor is not implicitly called
#endif
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sro/character/character.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sro_2fcharacter_2fcharacter_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_sro_2fcharacter_2fcharacter_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/api/annotations.pb.h"
#include "google/protobuf/empty.pb.h"
#include "sro/globals.pb.h"
#include "sro/gamebackend/servermanager.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sro_2fcharacter_2fcharacter_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sro_2fcharacter_2fcharacter_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_sro_2fcharacter_2fcharacter_2eproto;
namespace sro {
namespace character {
class AddPlayTimeRequest;
struct AddPlayTimeRequestDefaultTypeInternal;
extern AddPlayTimeRequestDefaultTypeInternal _AddPlayTimeRequest_default_instance_;
class CharacterDetails;
struct CharacterDetailsDefaultTypeInternal;
extern CharacterDetailsDefaultTypeInternal _CharacterDetails_default_instance_;
class CharacterTarget;
struct CharacterTargetDefaultTypeInternal;
extern CharacterTargetDefaultTypeInternal _CharacterTarget_default_instance_;
class CharactersDetails;
struct CharactersDetailsDefaultTypeInternal;
extern CharactersDetailsDefaultTypeInternal _CharactersDetails_default_instance_;
class CreateCharacterRequest;
struct CreateCharacterRequestDefaultTypeInternal;
extern CreateCharacterRequestDefaultTypeInternal _CreateCharacterRequest_default_instance_;
class EditCharacterRequest;
struct EditCharacterRequestDefaultTypeInternal;
extern EditCharacterRequestDefaultTypeInternal _EditCharacterRequest_default_instance_;
class Inventory;
struct InventoryDefaultTypeInternal;
extern InventoryDefaultTypeInternal _Inventory_default_instance_;
class InventoryItem;
struct InventoryItemDefaultTypeInternal;
extern InventoryItemDefaultTypeInternal _InventoryItem_default_instance_;
class PlayTimeResponse;
struct PlayTimeResponseDefaultTypeInternal;
extern PlayTimeResponseDefaultTypeInternal _PlayTimeResponse_default_instance_;
class UpdateInventoryRequest;
struct UpdateInventoryRequestDefaultTypeInternal;
extern UpdateInventoryRequestDefaultTypeInternal _UpdateInventoryRequest_default_instance_;
}  // namespace character
}  // namespace sro
PROTOBUF_NAMESPACE_OPEN
template <>
::sro::character::AddPlayTimeRequest* Arena::CreateMaybeMessage<::sro::character::AddPlayTimeRequest>(Arena*);
template <>
::sro::character::CharacterDetails* Arena::CreateMaybeMessage<::sro::character::CharacterDetails>(Arena*);
template <>
::sro::character::CharacterTarget* Arena::CreateMaybeMessage<::sro::character::CharacterTarget>(Arena*);
template <>
::sro::character::CharactersDetails* Arena::CreateMaybeMessage<::sro::character::CharactersDetails>(Arena*);
template <>
::sro::character::CreateCharacterRequest* Arena::CreateMaybeMessage<::sro::character::CreateCharacterRequest>(Arena*);
template <>
::sro::character::EditCharacterRequest* Arena::CreateMaybeMessage<::sro::character::EditCharacterRequest>(Arena*);
template <>
::sro::character::Inventory* Arena::CreateMaybeMessage<::sro::character::Inventory>(Arena*);
template <>
::sro::character::InventoryItem* Arena::CreateMaybeMessage<::sro::character::InventoryItem>(Arena*);
template <>
::sro::character::PlayTimeResponse* Arena::CreateMaybeMessage<::sro::character::PlayTimeResponse>(Arena*);
template <>
::sro::character::UpdateInventoryRequest* Arena::CreateMaybeMessage<::sro::character::UpdateInventoryRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace sro {
namespace character {

// ===================================================================


// -------------------------------------------------------------------

class PlayTimeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.character.PlayTimeResponse) */ {
 public:
  inline PlayTimeResponse() : PlayTimeResponse(nullptr) {}
  ~PlayTimeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayTimeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayTimeResponse(const PlayTimeResponse& from);
  PlayTimeResponse(PlayTimeResponse&& from) noexcept
    : PlayTimeResponse() {
    *this = ::std::move(from);
  }

  inline PlayTimeResponse& operator=(const PlayTimeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayTimeResponse& operator=(PlayTimeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayTimeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayTimeResponse* internal_default_instance() {
    return reinterpret_cast<const PlayTimeResponse*>(
               &_PlayTimeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PlayTimeResponse& a, PlayTimeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayTimeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayTimeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayTimeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayTimeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayTimeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayTimeResponse& from) {
    PlayTimeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayTimeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.character.PlayTimeResponse";
  }
  protected:
  explicit PlayTimeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
  };
  // uint64 time = 1;
  void clear_time() ;
  ::uint64_t time() const;
  void set_time(::uint64_t value);

  private:
  ::uint64_t _internal_time() const;
  void _internal_set_time(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:sro.character.PlayTimeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fcharacter_2fcharacter_2eproto;
};// -------------------------------------------------------------------

class AddPlayTimeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.character.AddPlayTimeRequest) */ {
 public:
  inline AddPlayTimeRequest() : AddPlayTimeRequest(nullptr) {}
  ~AddPlayTimeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AddPlayTimeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddPlayTimeRequest(const AddPlayTimeRequest& from);
  AddPlayTimeRequest(AddPlayTimeRequest&& from) noexcept
    : AddPlayTimeRequest() {
    *this = ::std::move(from);
  }

  inline AddPlayTimeRequest& operator=(const AddPlayTimeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPlayTimeRequest& operator=(AddPlayTimeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddPlayTimeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPlayTimeRequest* internal_default_instance() {
    return reinterpret_cast<const AddPlayTimeRequest*>(
               &_AddPlayTimeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AddPlayTimeRequest& a, AddPlayTimeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPlayTimeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPlayTimeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddPlayTimeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddPlayTimeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddPlayTimeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddPlayTimeRequest& from) {
    AddPlayTimeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPlayTimeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.character.AddPlayTimeRequest";
  }
  protected:
  explicit AddPlayTimeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // .sro.character.CharacterTarget character = 1;
  bool has_character() const;
  void clear_character() ;
  const ::sro::character::CharacterTarget& character() const;
  PROTOBUF_NODISCARD ::sro::character::CharacterTarget* release_character();
  ::sro::character::CharacterTarget* mutable_character();
  void set_allocated_character(::sro::character::CharacterTarget* character);
  private:
  const ::sro::character::CharacterTarget& _internal_character() const;
  ::sro::character::CharacterTarget* _internal_mutable_character();
  public:
  void unsafe_arena_set_allocated_character(
      ::sro::character::CharacterTarget* character);
  ::sro::character::CharacterTarget* unsafe_arena_release_character();
  // uint64 time = 2;
  void clear_time() ;
  ::uint64_t time() const;
  void set_time(::uint64_t value);

  private:
  ::uint64_t _internal_time() const;
  void _internal_set_time(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:sro.character.AddPlayTimeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::sro::character::CharacterTarget* character_;
    ::uint64_t time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fcharacter_2fcharacter_2eproto;
};// -------------------------------------------------------------------

class CreateCharacterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.character.CreateCharacterRequest) */ {
 public:
  inline CreateCharacterRequest() : CreateCharacterRequest(nullptr) {}
  ~CreateCharacterRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateCharacterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateCharacterRequest(const CreateCharacterRequest& from);
  CreateCharacterRequest(CreateCharacterRequest&& from) noexcept
    : CreateCharacterRequest() {
    *this = ::std::move(from);
  }

  inline CreateCharacterRequest& operator=(const CreateCharacterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCharacterRequest& operator=(CreateCharacterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCharacterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCharacterRequest* internal_default_instance() {
    return reinterpret_cast<const CreateCharacterRequest*>(
               &_CreateCharacterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateCharacterRequest& a, CreateCharacterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateCharacterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCharacterRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateCharacterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateCharacterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateCharacterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateCharacterRequest& from) {
    CreateCharacterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateCharacterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.character.CreateCharacterRequest";
  }
  protected:
  explicit CreateCharacterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kGenderFieldNumber = 3,
    kRealmFieldNumber = 4,
    kOwnerFieldNumber = 1,
    kDimensionFieldNumber = 5,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string gender = 3;
  void clear_gender() ;
  const std::string& gender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gender(Arg_&& arg, Args_... args);
  std::string* mutable_gender();
  PROTOBUF_NODISCARD std::string* release_gender();
  void set_allocated_gender(std::string* ptr);

  private:
  const std::string& _internal_gender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gender(
      const std::string& value);
  std::string* _internal_mutable_gender();

  public:
  // string realm = 4;
  void clear_realm() ;
  const std::string& realm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_realm(Arg_&& arg, Args_... args);
  std::string* mutable_realm();
  PROTOBUF_NODISCARD std::string* release_realm();
  void set_allocated_realm(std::string* ptr);

  private:
  const std::string& _internal_realm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realm(
      const std::string& value);
  std::string* _internal_mutable_realm();

  public:
  // .sro.UserTarget owner = 1;
  bool has_owner() const;
  void clear_owner() ;
  const ::sro::UserTarget& owner() const;
  PROTOBUF_NODISCARD ::sro::UserTarget* release_owner();
  ::sro::UserTarget* mutable_owner();
  void set_allocated_owner(::sro::UserTarget* owner);
  private:
  const ::sro::UserTarget& _internal_owner() const;
  ::sro::UserTarget* _internal_mutable_owner();
  public:
  void unsafe_arena_set_allocated_owner(
      ::sro::UserTarget* owner);
  ::sro::UserTarget* unsafe_arena_release_owner();
  // .sro.gamebackend.DimensionTarget dimension = 5;
  bool has_dimension() const;
  void clear_dimension() ;
  const ::sro::gamebackend::DimensionTarget& dimension() const;
  PROTOBUF_NODISCARD ::sro::gamebackend::DimensionTarget* release_dimension();
  ::sro::gamebackend::DimensionTarget* mutable_dimension();
  void set_allocated_dimension(::sro::gamebackend::DimensionTarget* dimension);
  private:
  const ::sro::gamebackend::DimensionTarget& _internal_dimension() const;
  ::sro::gamebackend::DimensionTarget* _internal_mutable_dimension();
  public:
  void unsafe_arena_set_allocated_dimension(
      ::sro::gamebackend::DimensionTarget* dimension);
  ::sro::gamebackend::DimensionTarget* unsafe_arena_release_dimension();
  // @@protoc_insertion_point(class_scope:sro.character.CreateCharacterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realm_;
    ::sro::UserTarget* owner_;
    ::sro::gamebackend::DimensionTarget* dimension_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fcharacter_2fcharacter_2eproto;
};// -------------------------------------------------------------------

class CharacterTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.character.CharacterTarget) */ {
 public:
  inline CharacterTarget() : CharacterTarget(nullptr) {}
  ~CharacterTarget() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CharacterTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterTarget(const CharacterTarget& from);
  CharacterTarget(CharacterTarget&& from) noexcept
    : CharacterTarget() {
    *this = ::std::move(from);
  }

  inline CharacterTarget& operator=(const CharacterTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterTarget& operator=(CharacterTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterTarget& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kId = 1,
    kName = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const CharacterTarget* internal_default_instance() {
    return reinterpret_cast<const CharacterTarget*>(
               &_CharacterTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CharacterTarget& a, CharacterTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterTarget* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharacterTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CharacterTarget& from) {
    CharacterTarget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharacterTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.character.CharacterTarget";
  }
  protected:
  explicit CharacterTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // uint64 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:sro.character.CharacterTarget)
 private:
  class _Internal;
  void set_has_id();
  void set_has_name();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::uint64_t id_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    } type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fcharacter_2fcharacter_2eproto;
};// -------------------------------------------------------------------

class EditCharacterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.character.EditCharacterRequest) */ {
 public:
  inline EditCharacterRequest() : EditCharacterRequest(nullptr) {}
  ~EditCharacterRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EditCharacterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCharacterRequest(const EditCharacterRequest& from);
  EditCharacterRequest(EditCharacterRequest&& from) noexcept
    : EditCharacterRequest() {
    *this = ::std::move(from);
  }

  inline EditCharacterRequest& operator=(const EditCharacterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCharacterRequest& operator=(EditCharacterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCharacterRequest& default_instance() {
    return *internal_default_instance();
  }
  enum OptionalOwnerIdCase {
    kOwnerId = 3,
    OPTIONAL_OWNER_ID_NOT_SET = 0,
  };

  enum OptionalNewNameCase {
    kNewName = 4,
    OPTIONAL_NEW_NAME_NOT_SET = 0,
  };

  enum OptionalGenderCase {
    kGender = 5,
    OPTIONAL_GENDER_NOT_SET = 0,
  };

  enum OptionalRealmCase {
    kRealm = 6,
    OPTIONAL_REALM_NOT_SET = 0,
  };

  enum OptionalPlayTimeCase {
    kPlayTime = 7,
    OPTIONAL_PLAY_TIME_NOT_SET = 0,
  };

  enum OptionalLocationCase {
    kLocation = 8,
    OPTIONAL_LOCATION_NOT_SET = 0,
  };

  enum OptionalDimensionCase {
    kDimension = 9,
    OPTIONAL_DIMENSION_NOT_SET = 0,
  };

  static inline const EditCharacterRequest* internal_default_instance() {
    return reinterpret_cast<const EditCharacterRequest*>(
               &_EditCharacterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EditCharacterRequest& a, EditCharacterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCharacterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCharacterRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCharacterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCharacterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCharacterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCharacterRequest& from) {
    EditCharacterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCharacterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.character.EditCharacterRequest";
  }
  protected:
  explicit EditCharacterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetFieldNumber = 1,
    kOwnerIdFieldNumber = 3,
    kNewNameFieldNumber = 4,
    kGenderFieldNumber = 5,
    kRealmFieldNumber = 6,
    kPlayTimeFieldNumber = 7,
    kLocationFieldNumber = 8,
    kDimensionFieldNumber = 9,
  };
  // .sro.character.CharacterTarget target = 1;
  bool has_target() const;
  void clear_target() ;
  const ::sro::character::CharacterTarget& target() const;
  PROTOBUF_NODISCARD ::sro::character::CharacterTarget* release_target();
  ::sro::character::CharacterTarget* mutable_target();
  void set_allocated_target(::sro::character::CharacterTarget* target);
  private:
  const ::sro::character::CharacterTarget& _internal_target() const;
  ::sro::character::CharacterTarget* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::sro::character::CharacterTarget* target);
  ::sro::character::CharacterTarget* unsafe_arena_release_target();
  // string owner_id = 3;
  bool has_owner_id() const;
  void clear_owner_id() ;
  const std::string& owner_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owner_id(Arg_&& arg, Args_... args);
  std::string* mutable_owner_id();
  PROTOBUF_NODISCARD std::string* release_owner_id();
  void set_allocated_owner_id(std::string* ptr);

  private:
  const std::string& _internal_owner_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_id(
      const std::string& value);
  std::string* _internal_mutable_owner_id();

  public:
  // string new_name = 4;
  bool has_new_name() const;
  void clear_new_name() ;
  const std::string& new_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_name(Arg_&& arg, Args_... args);
  std::string* mutable_new_name();
  PROTOBUF_NODISCARD std::string* release_new_name();
  void set_allocated_new_name(std::string* ptr);

  private:
  const std::string& _internal_new_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_name(
      const std::string& value);
  std::string* _internal_mutable_new_name();

  public:
  // string gender = 5;
  bool has_gender() const;
  void clear_gender() ;
  const std::string& gender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gender(Arg_&& arg, Args_... args);
  std::string* mutable_gender();
  PROTOBUF_NODISCARD std::string* release_gender();
  void set_allocated_gender(std::string* ptr);

  private:
  const std::string& _internal_gender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gender(
      const std::string& value);
  std::string* _internal_mutable_gender();

  public:
  // string realm = 6;
  bool has_realm() const;
  void clear_realm() ;
  const std::string& realm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_realm(Arg_&& arg, Args_... args);
  std::string* mutable_realm();
  PROTOBUF_NODISCARD std::string* release_realm();
  void set_allocated_realm(std::string* ptr);

  private:
  const std::string& _internal_realm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realm(
      const std::string& value);
  std::string* _internal_mutable_realm();

  public:
  // uint64 play_time = 7;
  bool has_play_time() const;
  void clear_play_time() ;
  ::uint64_t play_time() const;
  void set_play_time(::uint64_t value);

  private:
  ::uint64_t _internal_play_time() const;
  void _internal_set_play_time(::uint64_t value);

  public:
  // .sro.Location location = 8;
  bool has_location() const;
  private:
  bool _internal_has_location() const;

  public:
  void clear_location() ;
  const ::sro::Location& location() const;
  PROTOBUF_NODISCARD ::sro::Location* release_location();
  ::sro::Location* mutable_location();
  void set_allocated_location(::sro::Location* location);
  private:
  const ::sro::Location& _internal_location() const;
  ::sro::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::sro::Location* location);
  ::sro::Location* unsafe_arena_release_location();
  // .sro.gamebackend.DimensionTarget dimension = 9;
  bool has_dimension() const;
  private:
  bool _internal_has_dimension() const;

  public:
  void clear_dimension() ;
  const ::sro::gamebackend::DimensionTarget& dimension() const;
  PROTOBUF_NODISCARD ::sro::gamebackend::DimensionTarget* release_dimension();
  ::sro::gamebackend::DimensionTarget* mutable_dimension();
  void set_allocated_dimension(::sro::gamebackend::DimensionTarget* dimension);
  private:
  const ::sro::gamebackend::DimensionTarget& _internal_dimension() const;
  ::sro::gamebackend::DimensionTarget* _internal_mutable_dimension();
  public:
  void unsafe_arena_set_allocated_dimension(
      ::sro::gamebackend::DimensionTarget* dimension);
  ::sro::gamebackend::DimensionTarget* unsafe_arena_release_dimension();
  void clear_optional_owner_id();
  OptionalOwnerIdCase optional_owner_id_case() const;
  void clear_optional_new_name();
  OptionalNewNameCase optional_new_name_case() const;
  void clear_optional_gender();
  OptionalGenderCase optional_gender_case() const;
  void clear_optional_realm();
  OptionalRealmCase optional_realm_case() const;
  void clear_optional_play_time();
  OptionalPlayTimeCase optional_play_time_case() const;
  void clear_optional_location();
  OptionalLocationCase optional_location_case() const;
  void clear_optional_dimension();
  OptionalDimensionCase optional_dimension_case() const;
  // @@protoc_insertion_point(class_scope:sro.character.EditCharacterRequest)
 private:
  class _Internal;
  void set_has_owner_id();
  void set_has_new_name();
  void set_has_gender();
  void set_has_realm();
  void set_has_play_time();
  void set_has_location();
  void set_has_dimension();

  inline bool has_optional_owner_id() const;
  inline void clear_has_optional_owner_id();

  inline bool has_optional_new_name() const;
  inline void clear_has_optional_new_name();

  inline bool has_optional_gender() const;
  inline void clear_has_optional_gender();

  inline bool has_optional_realm() const;
  inline void clear_has_optional_realm();

  inline bool has_optional_play_time() const;
  inline void clear_has_optional_play_time();

  inline bool has_optional_location() const;
  inline void clear_has_optional_location();

  inline bool has_optional_dimension() const;
  inline void clear_has_optional_dimension();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::sro::character::CharacterTarget* target_;
    union OptionalOwnerIdUnion {
      constexpr OptionalOwnerIdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_id_;
    } optional_owner_id_;
    union OptionalNewNameUnion {
      constexpr OptionalNewNameUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_name_;
    } optional_new_name_;
    union OptionalGenderUnion {
      constexpr OptionalGenderUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gender_;
    } optional_gender_;
    union OptionalRealmUnion {
      constexpr OptionalRealmUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realm_;
    } optional_realm_;
    union OptionalPlayTimeUnion {
      constexpr OptionalPlayTimeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::uint64_t play_time_;
    } optional_play_time_;
    union OptionalLocationUnion {
      constexpr OptionalLocationUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::sro::Location* location_;
    } optional_location_;
    union OptionalDimensionUnion {
      constexpr OptionalDimensionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::sro::gamebackend::DimensionTarget* dimension_;
    } optional_dimension_;
    ::uint32_t _oneof_case_[7];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fcharacter_2fcharacter_2eproto;
};// -------------------------------------------------------------------

class CharacterDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.character.CharacterDetails) */ {
 public:
  inline CharacterDetails() : CharacterDetails(nullptr) {}
  ~CharacterDetails() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CharacterDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterDetails(const CharacterDetails& from);
  CharacterDetails(CharacterDetails&& from) noexcept
    : CharacterDetails() {
    *this = ::std::move(from);
  }

  inline CharacterDetails& operator=(const CharacterDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterDetails& operator=(CharacterDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterDetails* internal_default_instance() {
    return reinterpret_cast<const CharacterDetails*>(
               &_CharacterDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CharacterDetails& a, CharacterDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharacterDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CharacterDetails& from) {
    CharacterDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharacterDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.character.CharacterDetails";
  }
  protected:
  explicit CharacterDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerFieldNumber = 2,
    kNameFieldNumber = 3,
    kGenderFieldNumber = 4,
    kRealmFieldNumber = 5,
    kDimensionFieldNumber = 9,
    kLocationFieldNumber = 8,
    kIdFieldNumber = 1,
    kPlayTimeFieldNumber = 6,
  };
  // string owner = 2;
  void clear_owner() ;
  const std::string& owner() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owner(Arg_&& arg, Args_... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* ptr);

  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(
      const std::string& value);
  std::string* _internal_mutable_owner();

  public:
  // string name = 3;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string gender = 4;
  void clear_gender() ;
  const std::string& gender() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gender(Arg_&& arg, Args_... args);
  std::string* mutable_gender();
  PROTOBUF_NODISCARD std::string* release_gender();
  void set_allocated_gender(std::string* ptr);

  private:
  const std::string& _internal_gender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gender(
      const std::string& value);
  std::string* _internal_mutable_gender();

  public:
  // string realm = 5;
  void clear_realm() ;
  const std::string& realm() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_realm(Arg_&& arg, Args_... args);
  std::string* mutable_realm();
  PROTOBUF_NODISCARD std::string* release_realm();
  void set_allocated_realm(std::string* ptr);

  private:
  const std::string& _internal_realm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_realm(
      const std::string& value);
  std::string* _internal_mutable_realm();

  public:
  // string dimension = 9;
  void clear_dimension() ;
  const std::string& dimension() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dimension(Arg_&& arg, Args_... args);
  std::string* mutable_dimension();
  PROTOBUF_NODISCARD std::string* release_dimension();
  void set_allocated_dimension(std::string* ptr);

  private:
  const std::string& _internal_dimension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dimension(
      const std::string& value);
  std::string* _internal_mutable_dimension();

  public:
  // .sro.Location location = 8;
  bool has_location() const;
  void clear_location() ;
  const ::sro::Location& location() const;
  PROTOBUF_NODISCARD ::sro::Location* release_location();
  ::sro::Location* mutable_location();
  void set_allocated_location(::sro::Location* location);
  private:
  const ::sro::Location& _internal_location() const;
  ::sro::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::sro::Location* location);
  ::sro::Location* unsafe_arena_release_location();
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint64 play_time = 6;
  void clear_play_time() ;
  ::uint64_t play_time() const;
  void set_play_time(::uint64_t value);

  private:
  ::uint64_t _internal_play_time() const;
  void _internal_set_play_time(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:sro.character.CharacterDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gender_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr realm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dimension_;
    ::sro::Location* location_;
    ::uint64_t id_;
    ::uint64_t play_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fcharacter_2fcharacter_2eproto;
};// -------------------------------------------------------------------

class CharactersDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.character.CharactersDetails) */ {
 public:
  inline CharactersDetails() : CharactersDetails(nullptr) {}
  ~CharactersDetails() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CharactersDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharactersDetails(const CharactersDetails& from);
  CharactersDetails(CharactersDetails&& from) noexcept
    : CharactersDetails() {
    *this = ::std::move(from);
  }

  inline CharactersDetails& operator=(const CharactersDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharactersDetails& operator=(CharactersDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharactersDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharactersDetails* internal_default_instance() {
    return reinterpret_cast<const CharactersDetails*>(
               &_CharactersDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CharactersDetails& a, CharactersDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(CharactersDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharactersDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharactersDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharactersDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharactersDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CharactersDetails& from) {
    CharactersDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharactersDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.character.CharactersDetails";
  }
  protected:
  explicit CharactersDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharactersFieldNumber = 1,
  };
  // repeated .sro.character.CharacterDetails characters = 1;
  int characters_size() const;
  private:
  int _internal_characters_size() const;

  public:
  void clear_characters() ;
  ::sro::character::CharacterDetails* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::CharacterDetails >*
      mutable_characters();
  private:
  const ::sro::character::CharacterDetails& _internal_characters(int index) const;
  ::sro::character::CharacterDetails* _internal_add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::CharacterDetails>& _internal_characters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::CharacterDetails>* _internal_mutable_characters();
  public:
  const ::sro::character::CharacterDetails& characters(int index) const;
  ::sro::character::CharacterDetails* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::CharacterDetails >&
      characters() const;
  // @@protoc_insertion_point(class_scope:sro.character.CharactersDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::CharacterDetails > characters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fcharacter_2fcharacter_2eproto;
};// -------------------------------------------------------------------

class InventoryItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.character.InventoryItem) */ {
 public:
  inline InventoryItem() : InventoryItem(nullptr) {}
  ~InventoryItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InventoryItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InventoryItem(const InventoryItem& from);
  InventoryItem(InventoryItem&& from) noexcept
    : InventoryItem() {
    *this = ::std::move(from);
  }

  inline InventoryItem& operator=(const InventoryItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryItem& operator=(InventoryItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventoryItem* internal_default_instance() {
    return reinterpret_cast<const InventoryItem*>(
               &_InventoryItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InventoryItem& a, InventoryItem& b) {
    a.Swap(&b);
  }
  inline void Swap(InventoryItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventoryItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventoryItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InventoryItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InventoryItem& from) {
    InventoryItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InventoryItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.character.InventoryItem";
  }
  protected:
  explicit InventoryItem(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kQuantityFieldNumber = 3,
    kSlotFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // uint64 quantity = 3;
  void clear_quantity() ;
  ::uint64_t quantity() const;
  void set_quantity(::uint64_t value);

  private:
  ::uint64_t _internal_quantity() const;
  void _internal_set_quantity(::uint64_t value);

  public:
  // uint32 slot = 2;
  void clear_slot() ;
  ::uint32_t slot() const;
  void set_slot(::uint32_t value);

  private:
  ::uint32_t _internal_slot() const;
  void _internal_set_slot(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:sro.character.InventoryItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::uint64_t quantity_;
    ::uint32_t slot_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fcharacter_2fcharacter_2eproto;
};// -------------------------------------------------------------------

class Inventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.character.Inventory) */ {
 public:
  inline Inventory() : Inventory(nullptr) {}
  ~Inventory() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Inventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Inventory(const Inventory& from);
  Inventory(Inventory&& from) noexcept
    : Inventory() {
    *this = ::std::move(from);
  }

  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inventory& operator=(Inventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Inventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const Inventory* internal_default_instance() {
    return reinterpret_cast<const Inventory*>(
               &_Inventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Inventory& a, Inventory& b) {
    a.Swap(&b);
  }
  inline void Swap(Inventory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Inventory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Inventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Inventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Inventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Inventory& from) {
    Inventory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Inventory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.character.Inventory";
  }
  protected:
  explicit Inventory(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInventoryItemsFieldNumber = 1,
    kBankItemsFieldNumber = 2,
  };
  // repeated .sro.character.InventoryItem inventory_items = 1;
  int inventory_items_size() const;
  private:
  int _internal_inventory_items_size() const;

  public:
  void clear_inventory_items() ;
  ::sro::character::InventoryItem* mutable_inventory_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >*
      mutable_inventory_items();
  private:
  const ::sro::character::InventoryItem& _internal_inventory_items(int index) const;
  ::sro::character::InventoryItem* _internal_add_inventory_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>& _internal_inventory_items() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>* _internal_mutable_inventory_items();
  public:
  const ::sro::character::InventoryItem& inventory_items(int index) const;
  ::sro::character::InventoryItem* add_inventory_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >&
      inventory_items() const;
  // repeated .sro.character.InventoryItem bank_items = 2;
  int bank_items_size() const;
  private:
  int _internal_bank_items_size() const;

  public:
  void clear_bank_items() ;
  ::sro::character::InventoryItem* mutable_bank_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >*
      mutable_bank_items();
  private:
  const ::sro::character::InventoryItem& _internal_bank_items(int index) const;
  ::sro::character::InventoryItem* _internal_add_bank_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>& _internal_bank_items() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>* _internal_mutable_bank_items();
  public:
  const ::sro::character::InventoryItem& bank_items(int index) const;
  ::sro::character::InventoryItem* add_bank_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >&
      bank_items() const;
  // @@protoc_insertion_point(class_scope:sro.character.Inventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem > inventory_items_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem > bank_items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fcharacter_2fcharacter_2eproto;
};// -------------------------------------------------------------------

class UpdateInventoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sro.character.UpdateInventoryRequest) */ {
 public:
  inline UpdateInventoryRequest() : UpdateInventoryRequest(nullptr) {}
  ~UpdateInventoryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateInventoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateInventoryRequest(const UpdateInventoryRequest& from);
  UpdateInventoryRequest(UpdateInventoryRequest&& from) noexcept
    : UpdateInventoryRequest() {
    *this = ::std::move(from);
  }

  inline UpdateInventoryRequest& operator=(const UpdateInventoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateInventoryRequest& operator=(UpdateInventoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateInventoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateInventoryRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateInventoryRequest*>(
               &_UpdateInventoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateInventoryRequest& a, UpdateInventoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateInventoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateInventoryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateInventoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateInventoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateInventoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateInventoryRequest& from) {
    UpdateInventoryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateInventoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sro.character.UpdateInventoryRequest";
  }
  protected:
  explicit UpdateInventoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInventoryItemsFieldNumber = 2,
    kBankItemsFieldNumber = 3,
    kTargetFieldNumber = 1,
  };
  // repeated .sro.character.InventoryItem inventory_items = 2;
  int inventory_items_size() const;
  private:
  int _internal_inventory_items_size() const;

  public:
  void clear_inventory_items() ;
  ::sro::character::InventoryItem* mutable_inventory_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >*
      mutable_inventory_items();
  private:
  const ::sro::character::InventoryItem& _internal_inventory_items(int index) const;
  ::sro::character::InventoryItem* _internal_add_inventory_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>& _internal_inventory_items() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>* _internal_mutable_inventory_items();
  public:
  const ::sro::character::InventoryItem& inventory_items(int index) const;
  ::sro::character::InventoryItem* add_inventory_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >&
      inventory_items() const;
  // repeated .sro.character.InventoryItem bank_items = 3;
  int bank_items_size() const;
  private:
  int _internal_bank_items_size() const;

  public:
  void clear_bank_items() ;
  ::sro::character::InventoryItem* mutable_bank_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >*
      mutable_bank_items();
  private:
  const ::sro::character::InventoryItem& _internal_bank_items(int index) const;
  ::sro::character::InventoryItem* _internal_add_bank_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>& _internal_bank_items() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>* _internal_mutable_bank_items();
  public:
  const ::sro::character::InventoryItem& bank_items(int index) const;
  ::sro::character::InventoryItem* add_bank_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >&
      bank_items() const;
  // .sro.character.CharacterTarget target = 1;
  bool has_target() const;
  void clear_target() ;
  const ::sro::character::CharacterTarget& target() const;
  PROTOBUF_NODISCARD ::sro::character::CharacterTarget* release_target();
  ::sro::character::CharacterTarget* mutable_target();
  void set_allocated_target(::sro::character::CharacterTarget* target);
  private:
  const ::sro::character::CharacterTarget& _internal_target() const;
  ::sro::character::CharacterTarget* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::sro::character::CharacterTarget* target);
  ::sro::character::CharacterTarget* unsafe_arena_release_target();
  // @@protoc_insertion_point(class_scope:sro.character.UpdateInventoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem > inventory_items_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem > bank_items_;
    ::sro::character::CharacterTarget* target_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sro_2fcharacter_2fcharacter_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PlayTimeResponse

// uint64 time = 1;
inline void PlayTimeResponse::clear_time() {
  _impl_.time_ = ::uint64_t{0u};
}
inline ::uint64_t PlayTimeResponse::time() const {
  // @@protoc_insertion_point(field_get:sro.character.PlayTimeResponse.time)
  return _internal_time();
}
inline void PlayTimeResponse::set_time(::uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:sro.character.PlayTimeResponse.time)
}
inline ::uint64_t PlayTimeResponse::_internal_time() const {
  return _impl_.time_;
}
inline void PlayTimeResponse::_internal_set_time(::uint64_t value) {
  ;
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// AddPlayTimeRequest

// .sro.character.CharacterTarget character = 1;
inline bool AddPlayTimeRequest::has_character() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.character_ != nullptr);
  return value;
}
inline void AddPlayTimeRequest::clear_character() {
  if (_impl_.character_ != nullptr) _impl_.character_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sro::character::CharacterTarget& AddPlayTimeRequest::_internal_character() const {
  const ::sro::character::CharacterTarget* p = _impl_.character_;
  return p != nullptr ? *p : reinterpret_cast<const ::sro::character::CharacterTarget&>(
      ::sro::character::_CharacterTarget_default_instance_);
}
inline const ::sro::character::CharacterTarget& AddPlayTimeRequest::character() const {
  // @@protoc_insertion_point(field_get:sro.character.AddPlayTimeRequest.character)
  return _internal_character();
}
inline void AddPlayTimeRequest::unsafe_arena_set_allocated_character(
    ::sro::character::CharacterTarget* character) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.character_);
  }
  _impl_.character_ = character;
  if (character) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.character.AddPlayTimeRequest.character)
}
inline ::sro::character::CharacterTarget* AddPlayTimeRequest::release_character() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::character::CharacterTarget* temp = _impl_.character_;
  _impl_.character_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sro::character::CharacterTarget* AddPlayTimeRequest::unsafe_arena_release_character() {
  // @@protoc_insertion_point(field_release:sro.character.AddPlayTimeRequest.character)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::character::CharacterTarget* temp = _impl_.character_;
  _impl_.character_ = nullptr;
  return temp;
}
inline ::sro::character::CharacterTarget* AddPlayTimeRequest::_internal_mutable_character() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.character_ == nullptr) {
    auto* p = CreateMaybeMessage<::sro::character::CharacterTarget>(GetArenaForAllocation());
    _impl_.character_ = p;
  }
  return _impl_.character_;
}
inline ::sro::character::CharacterTarget* AddPlayTimeRequest::mutable_character() {
  ::sro::character::CharacterTarget* _msg = _internal_mutable_character();
  // @@protoc_insertion_point(field_mutable:sro.character.AddPlayTimeRequest.character)
  return _msg;
}
inline void AddPlayTimeRequest::set_allocated_character(::sro::character::CharacterTarget* character) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.character_;
  }
  if (character) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(character);
    if (message_arena != submessage_arena) {
      character = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, character, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.character_ = character;
  // @@protoc_insertion_point(field_set_allocated:sro.character.AddPlayTimeRequest.character)
}

// uint64 time = 2;
inline void AddPlayTimeRequest::clear_time() {
  _impl_.time_ = ::uint64_t{0u};
}
inline ::uint64_t AddPlayTimeRequest::time() const {
  // @@protoc_insertion_point(field_get:sro.character.AddPlayTimeRequest.time)
  return _internal_time();
}
inline void AddPlayTimeRequest::set_time(::uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:sro.character.AddPlayTimeRequest.time)
}
inline ::uint64_t AddPlayTimeRequest::_internal_time() const {
  return _impl_.time_;
}
inline void AddPlayTimeRequest::_internal_set_time(::uint64_t value) {
  ;
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// CreateCharacterRequest

// .sro.UserTarget owner = 1;
inline bool CreateCharacterRequest::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.owner_ != nullptr);
  return value;
}
inline const ::sro::UserTarget& CreateCharacterRequest::_internal_owner() const {
  const ::sro::UserTarget* p = _impl_.owner_;
  return p != nullptr ? *p : reinterpret_cast<const ::sro::UserTarget&>(
      ::sro::_UserTarget_default_instance_);
}
inline const ::sro::UserTarget& CreateCharacterRequest::owner() const {
  // @@protoc_insertion_point(field_get:sro.character.CreateCharacterRequest.owner)
  return _internal_owner();
}
inline void CreateCharacterRequest::unsafe_arena_set_allocated_owner(
    ::sro::UserTarget* owner) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.owner_);
  }
  _impl_.owner_ = owner;
  if (owner) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.character.CreateCharacterRequest.owner)
}
inline ::sro::UserTarget* CreateCharacterRequest::release_owner() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::UserTarget* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sro::UserTarget* CreateCharacterRequest::unsafe_arena_release_owner() {
  // @@protoc_insertion_point(field_release:sro.character.CreateCharacterRequest.owner)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::UserTarget* temp = _impl_.owner_;
  _impl_.owner_ = nullptr;
  return temp;
}
inline ::sro::UserTarget* CreateCharacterRequest::_internal_mutable_owner() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.owner_ == nullptr) {
    auto* p = CreateMaybeMessage<::sro::UserTarget>(GetArenaForAllocation());
    _impl_.owner_ = p;
  }
  return _impl_.owner_;
}
inline ::sro::UserTarget* CreateCharacterRequest::mutable_owner() {
  ::sro::UserTarget* _msg = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:sro.character.CreateCharacterRequest.owner)
  return _msg;
}
inline void CreateCharacterRequest::set_allocated_owner(::sro::UserTarget* owner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.owner_);
  }
  if (owner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(owner));
    if (message_arena != submessage_arena) {
      owner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, owner, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.owner_ = owner;
  // @@protoc_insertion_point(field_set_allocated:sro.character.CreateCharacterRequest.owner)
}

// string name = 2;
inline void CreateCharacterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateCharacterRequest::name() const {
  // @@protoc_insertion_point(field_get:sro.character.CreateCharacterRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateCharacterRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.CreateCharacterRequest.name)
}
inline std::string* CreateCharacterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sro.character.CreateCharacterRequest.name)
  return _s;
}
inline const std::string& CreateCharacterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateCharacterRequest::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateCharacterRequest::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateCharacterRequest::release_name() {
  // @@protoc_insertion_point(field_release:sro.character.CreateCharacterRequest.name)
  return _impl_.name_.Release();
}
inline void CreateCharacterRequest::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.character.CreateCharacterRequest.name)
}

// string gender = 3;
inline void CreateCharacterRequest::clear_gender() {
  _impl_.gender_.ClearToEmpty();
}
inline const std::string& CreateCharacterRequest::gender() const {
  // @@protoc_insertion_point(field_get:sro.character.CreateCharacterRequest.gender)
  return _internal_gender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateCharacterRequest::set_gender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.gender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.CreateCharacterRequest.gender)
}
inline std::string* CreateCharacterRequest::mutable_gender() {
  std::string* _s = _internal_mutable_gender();
  // @@protoc_insertion_point(field_mutable:sro.character.CreateCharacterRequest.gender)
  return _s;
}
inline const std::string& CreateCharacterRequest::_internal_gender() const {
  return _impl_.gender_.Get();
}
inline void CreateCharacterRequest::_internal_set_gender(const std::string& value) {
  ;


  _impl_.gender_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateCharacterRequest::_internal_mutable_gender() {
  ;
  return _impl_.gender_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateCharacterRequest::release_gender() {
  // @@protoc_insertion_point(field_release:sro.character.CreateCharacterRequest.gender)
  return _impl_.gender_.Release();
}
inline void CreateCharacterRequest::set_allocated_gender(std::string* value) {
  _impl_.gender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gender_.IsDefault()) {
          _impl_.gender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.character.CreateCharacterRequest.gender)
}

// string realm = 4;
inline void CreateCharacterRequest::clear_realm() {
  _impl_.realm_.ClearToEmpty();
}
inline const std::string& CreateCharacterRequest::realm() const {
  // @@protoc_insertion_point(field_get:sro.character.CreateCharacterRequest.realm)
  return _internal_realm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateCharacterRequest::set_realm(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.realm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.CreateCharacterRequest.realm)
}
inline std::string* CreateCharacterRequest::mutable_realm() {
  std::string* _s = _internal_mutable_realm();
  // @@protoc_insertion_point(field_mutable:sro.character.CreateCharacterRequest.realm)
  return _s;
}
inline const std::string& CreateCharacterRequest::_internal_realm() const {
  return _impl_.realm_.Get();
}
inline void CreateCharacterRequest::_internal_set_realm(const std::string& value) {
  ;


  _impl_.realm_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateCharacterRequest::_internal_mutable_realm() {
  ;
  return _impl_.realm_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateCharacterRequest::release_realm() {
  // @@protoc_insertion_point(field_release:sro.character.CreateCharacterRequest.realm)
  return _impl_.realm_.Release();
}
inline void CreateCharacterRequest::set_allocated_realm(std::string* value) {
  _impl_.realm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.realm_.IsDefault()) {
          _impl_.realm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.character.CreateCharacterRequest.realm)
}

// .sro.gamebackend.DimensionTarget dimension = 5;
inline bool CreateCharacterRequest::has_dimension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dimension_ != nullptr);
  return value;
}
inline const ::sro::gamebackend::DimensionTarget& CreateCharacterRequest::_internal_dimension() const {
  const ::sro::gamebackend::DimensionTarget* p = _impl_.dimension_;
  return p != nullptr ? *p : reinterpret_cast<const ::sro::gamebackend::DimensionTarget&>(
      ::sro::gamebackend::_DimensionTarget_default_instance_);
}
inline const ::sro::gamebackend::DimensionTarget& CreateCharacterRequest::dimension() const {
  // @@protoc_insertion_point(field_get:sro.character.CreateCharacterRequest.dimension)
  return _internal_dimension();
}
inline void CreateCharacterRequest::unsafe_arena_set_allocated_dimension(
    ::sro::gamebackend::DimensionTarget* dimension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dimension_);
  }
  _impl_.dimension_ = dimension;
  if (dimension) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.character.CreateCharacterRequest.dimension)
}
inline ::sro::gamebackend::DimensionTarget* CreateCharacterRequest::release_dimension() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sro::gamebackend::DimensionTarget* temp = _impl_.dimension_;
  _impl_.dimension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sro::gamebackend::DimensionTarget* CreateCharacterRequest::unsafe_arena_release_dimension() {
  // @@protoc_insertion_point(field_release:sro.character.CreateCharacterRequest.dimension)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sro::gamebackend::DimensionTarget* temp = _impl_.dimension_;
  _impl_.dimension_ = nullptr;
  return temp;
}
inline ::sro::gamebackend::DimensionTarget* CreateCharacterRequest::_internal_mutable_dimension() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dimension_ == nullptr) {
    auto* p = CreateMaybeMessage<::sro::gamebackend::DimensionTarget>(GetArenaForAllocation());
    _impl_.dimension_ = p;
  }
  return _impl_.dimension_;
}
inline ::sro::gamebackend::DimensionTarget* CreateCharacterRequest::mutable_dimension() {
  ::sro::gamebackend::DimensionTarget* _msg = _internal_mutable_dimension();
  // @@protoc_insertion_point(field_mutable:sro.character.CreateCharacterRequest.dimension)
  return _msg;
}
inline void CreateCharacterRequest::set_allocated_dimension(::sro::gamebackend::DimensionTarget* dimension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dimension_);
  }
  if (dimension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dimension));
    if (message_arena != submessage_arena) {
      dimension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dimension, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dimension_ = dimension;
  // @@protoc_insertion_point(field_set_allocated:sro.character.CreateCharacterRequest.dimension)
}

// -------------------------------------------------------------------

// CharacterTarget

// uint64 id = 1;
inline bool CharacterTarget::has_id() const {
  return type_case() == kId;
}
inline void CharacterTarget::set_has_id() {
  _impl_._oneof_case_[0] = kId;
}
inline void CharacterTarget::clear_id() {
  if (type_case() == kId) {
    _impl_.type_.id_ = ::uint64_t{0u};
    clear_has_type();
  }
}
inline ::uint64_t CharacterTarget::id() const {
  // @@protoc_insertion_point(field_get:sro.character.CharacterTarget.id)
  return _internal_id();
}
inline void CharacterTarget::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sro.character.CharacterTarget.id)
}
inline ::uint64_t CharacterTarget::_internal_id() const {
  if (type_case() == kId) {
    return _impl_.type_.id_;
  }
  return ::uint64_t{0u};
}
inline void CharacterTarget::_internal_set_id(::uint64_t value) {
  if (type_case() != kId) {
    clear_type();
    set_has_id();
  }
  _impl_.type_.id_ = value;
}

// string name = 2;
inline bool CharacterTarget::has_name() const {
  return type_case() == kName;
}
inline void CharacterTarget::set_has_name() {
  _impl_._oneof_case_[0] = kName;
}
inline void CharacterTarget::clear_name() {
  if (type_case() == kName) {
    _impl_.type_.name_.Destroy();
    clear_has_type();
  }
}
inline const std::string& CharacterTarget::name() const {
  // @@protoc_insertion_point(field_get:sro.character.CharacterTarget.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CharacterTarget::set_name(Arg_&& arg,
                                                     Args_... args) {
  if (type_case() != kName) {
    clear_type();

    set_has_name();
    _impl_.type_.name_.InitDefault();
  }
  _impl_.type_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.CharacterTarget.name)
}
inline std::string* CharacterTarget::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sro.character.CharacterTarget.name)
  return _s;
}
inline const std::string& CharacterTarget::_internal_name() const {
  if (type_case() != kName) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.type_.name_.Get();
}
inline void CharacterTarget::_internal_set_name(const std::string& value) {
  if (type_case() != kName) {
    clear_type();

    set_has_name();
    _impl_.type_.name_.InitDefault();
  }


  _impl_.type_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CharacterTarget::_internal_mutable_name() {
  if (type_case() != kName) {
    clear_type();

    set_has_name();
    _impl_.type_.name_.InitDefault();
  }
  return _impl_.type_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* CharacterTarget::release_name() {
  // @@protoc_insertion_point(field_release:sro.character.CharacterTarget.name)
  if (type_case() != kName) {
    return nullptr;
  }
  clear_has_type();
  return _impl_.type_.name_.Release();
}
inline void CharacterTarget::set_allocated_name(std::string* value) {
  if (has_type()) {
    clear_type();
  }
  if (value != nullptr) {
    set_has_name();
    _impl_.type_.name_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:sro.character.CharacterTarget.name)
}

inline bool CharacterTarget::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void CharacterTarget::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline CharacterTarget::TypeCase CharacterTarget::type_case() const {
  return CharacterTarget::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EditCharacterRequest

// .sro.character.CharacterTarget target = 1;
inline bool EditCharacterRequest::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline void EditCharacterRequest::clear_target() {
  if (_impl_.target_ != nullptr) _impl_.target_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sro::character::CharacterTarget& EditCharacterRequest::_internal_target() const {
  const ::sro::character::CharacterTarget* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::sro::character::CharacterTarget&>(
      ::sro::character::_CharacterTarget_default_instance_);
}
inline const ::sro::character::CharacterTarget& EditCharacterRequest::target() const {
  // @@protoc_insertion_point(field_get:sro.character.EditCharacterRequest.target)
  return _internal_target();
}
inline void EditCharacterRequest::unsafe_arena_set_allocated_target(
    ::sro::character::CharacterTarget* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.character.EditCharacterRequest.target)
}
inline ::sro::character::CharacterTarget* EditCharacterRequest::release_target() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::character::CharacterTarget* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sro::character::CharacterTarget* EditCharacterRequest::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:sro.character.EditCharacterRequest.target)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::character::CharacterTarget* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::sro::character::CharacterTarget* EditCharacterRequest::_internal_mutable_target() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::sro::character::CharacterTarget>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::sro::character::CharacterTarget* EditCharacterRequest::mutable_target() {
  ::sro::character::CharacterTarget* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:sro.character.EditCharacterRequest.target)
  return _msg;
}
inline void EditCharacterRequest::set_allocated_target(::sro::character::CharacterTarget* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:sro.character.EditCharacterRequest.target)
}

// string owner_id = 3;
inline bool EditCharacterRequest::has_owner_id() const {
  return optional_owner_id_case() == kOwnerId;
}
inline void EditCharacterRequest::set_has_owner_id() {
  _impl_._oneof_case_[0] = kOwnerId;
}
inline void EditCharacterRequest::clear_owner_id() {
  if (optional_owner_id_case() == kOwnerId) {
    _impl_.optional_owner_id_.owner_id_.Destroy();
    clear_has_optional_owner_id();
  }
}
inline const std::string& EditCharacterRequest::owner_id() const {
  // @@protoc_insertion_point(field_get:sro.character.EditCharacterRequest.owner_id)
  return _internal_owner_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EditCharacterRequest::set_owner_id(Arg_&& arg,
                                                     Args_... args) {
  if (optional_owner_id_case() != kOwnerId) {
    clear_optional_owner_id();

    set_has_owner_id();
    _impl_.optional_owner_id_.owner_id_.InitDefault();
  }
  _impl_.optional_owner_id_.owner_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.EditCharacterRequest.owner_id)
}
inline std::string* EditCharacterRequest::mutable_owner_id() {
  std::string* _s = _internal_mutable_owner_id();
  // @@protoc_insertion_point(field_mutable:sro.character.EditCharacterRequest.owner_id)
  return _s;
}
inline const std::string& EditCharacterRequest::_internal_owner_id() const {
  if (optional_owner_id_case() != kOwnerId) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.optional_owner_id_.owner_id_.Get();
}
inline void EditCharacterRequest::_internal_set_owner_id(const std::string& value) {
  if (optional_owner_id_case() != kOwnerId) {
    clear_optional_owner_id();

    set_has_owner_id();
    _impl_.optional_owner_id_.owner_id_.InitDefault();
  }


  _impl_.optional_owner_id_.owner_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::_internal_mutable_owner_id() {
  if (optional_owner_id_case() != kOwnerId) {
    clear_optional_owner_id();

    set_has_owner_id();
    _impl_.optional_owner_id_.owner_id_.InitDefault();
  }
  return _impl_.optional_owner_id_.owner_id_.Mutable( GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::release_owner_id() {
  // @@protoc_insertion_point(field_release:sro.character.EditCharacterRequest.owner_id)
  if (optional_owner_id_case() != kOwnerId) {
    return nullptr;
  }
  clear_has_optional_owner_id();
  return _impl_.optional_owner_id_.owner_id_.Release();
}
inline void EditCharacterRequest::set_allocated_owner_id(std::string* value) {
  if (has_optional_owner_id()) {
    clear_optional_owner_id();
  }
  if (value != nullptr) {
    set_has_owner_id();
    _impl_.optional_owner_id_.owner_id_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:sro.character.EditCharacterRequest.owner_id)
}

// string new_name = 4;
inline bool EditCharacterRequest::has_new_name() const {
  return optional_new_name_case() == kNewName;
}
inline void EditCharacterRequest::set_has_new_name() {
  _impl_._oneof_case_[1] = kNewName;
}
inline void EditCharacterRequest::clear_new_name() {
  if (optional_new_name_case() == kNewName) {
    _impl_.optional_new_name_.new_name_.Destroy();
    clear_has_optional_new_name();
  }
}
inline const std::string& EditCharacterRequest::new_name() const {
  // @@protoc_insertion_point(field_get:sro.character.EditCharacterRequest.new_name)
  return _internal_new_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EditCharacterRequest::set_new_name(Arg_&& arg,
                                                     Args_... args) {
  if (optional_new_name_case() != kNewName) {
    clear_optional_new_name();

    set_has_new_name();
    _impl_.optional_new_name_.new_name_.InitDefault();
  }
  _impl_.optional_new_name_.new_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.EditCharacterRequest.new_name)
}
inline std::string* EditCharacterRequest::mutable_new_name() {
  std::string* _s = _internal_mutable_new_name();
  // @@protoc_insertion_point(field_mutable:sro.character.EditCharacterRequest.new_name)
  return _s;
}
inline const std::string& EditCharacterRequest::_internal_new_name() const {
  if (optional_new_name_case() != kNewName) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.optional_new_name_.new_name_.Get();
}
inline void EditCharacterRequest::_internal_set_new_name(const std::string& value) {
  if (optional_new_name_case() != kNewName) {
    clear_optional_new_name();

    set_has_new_name();
    _impl_.optional_new_name_.new_name_.InitDefault();
  }


  _impl_.optional_new_name_.new_name_.Set(value, GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::_internal_mutable_new_name() {
  if (optional_new_name_case() != kNewName) {
    clear_optional_new_name();

    set_has_new_name();
    _impl_.optional_new_name_.new_name_.InitDefault();
  }
  return _impl_.optional_new_name_.new_name_.Mutable( GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::release_new_name() {
  // @@protoc_insertion_point(field_release:sro.character.EditCharacterRequest.new_name)
  if (optional_new_name_case() != kNewName) {
    return nullptr;
  }
  clear_has_optional_new_name();
  return _impl_.optional_new_name_.new_name_.Release();
}
inline void EditCharacterRequest::set_allocated_new_name(std::string* value) {
  if (has_optional_new_name()) {
    clear_optional_new_name();
  }
  if (value != nullptr) {
    set_has_new_name();
    _impl_.optional_new_name_.new_name_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:sro.character.EditCharacterRequest.new_name)
}

// string gender = 5;
inline bool EditCharacterRequest::has_gender() const {
  return optional_gender_case() == kGender;
}
inline void EditCharacterRequest::set_has_gender() {
  _impl_._oneof_case_[2] = kGender;
}
inline void EditCharacterRequest::clear_gender() {
  if (optional_gender_case() == kGender) {
    _impl_.optional_gender_.gender_.Destroy();
    clear_has_optional_gender();
  }
}
inline const std::string& EditCharacterRequest::gender() const {
  // @@protoc_insertion_point(field_get:sro.character.EditCharacterRequest.gender)
  return _internal_gender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EditCharacterRequest::set_gender(Arg_&& arg,
                                                     Args_... args) {
  if (optional_gender_case() != kGender) {
    clear_optional_gender();

    set_has_gender();
    _impl_.optional_gender_.gender_.InitDefault();
  }
  _impl_.optional_gender_.gender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.EditCharacterRequest.gender)
}
inline std::string* EditCharacterRequest::mutable_gender() {
  std::string* _s = _internal_mutable_gender();
  // @@protoc_insertion_point(field_mutable:sro.character.EditCharacterRequest.gender)
  return _s;
}
inline const std::string& EditCharacterRequest::_internal_gender() const {
  if (optional_gender_case() != kGender) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.optional_gender_.gender_.Get();
}
inline void EditCharacterRequest::_internal_set_gender(const std::string& value) {
  if (optional_gender_case() != kGender) {
    clear_optional_gender();

    set_has_gender();
    _impl_.optional_gender_.gender_.InitDefault();
  }


  _impl_.optional_gender_.gender_.Set(value, GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::_internal_mutable_gender() {
  if (optional_gender_case() != kGender) {
    clear_optional_gender();

    set_has_gender();
    _impl_.optional_gender_.gender_.InitDefault();
  }
  return _impl_.optional_gender_.gender_.Mutable( GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::release_gender() {
  // @@protoc_insertion_point(field_release:sro.character.EditCharacterRequest.gender)
  if (optional_gender_case() != kGender) {
    return nullptr;
  }
  clear_has_optional_gender();
  return _impl_.optional_gender_.gender_.Release();
}
inline void EditCharacterRequest::set_allocated_gender(std::string* value) {
  if (has_optional_gender()) {
    clear_optional_gender();
  }
  if (value != nullptr) {
    set_has_gender();
    _impl_.optional_gender_.gender_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:sro.character.EditCharacterRequest.gender)
}

// string realm = 6;
inline bool EditCharacterRequest::has_realm() const {
  return optional_realm_case() == kRealm;
}
inline void EditCharacterRequest::set_has_realm() {
  _impl_._oneof_case_[3] = kRealm;
}
inline void EditCharacterRequest::clear_realm() {
  if (optional_realm_case() == kRealm) {
    _impl_.optional_realm_.realm_.Destroy();
    clear_has_optional_realm();
  }
}
inline const std::string& EditCharacterRequest::realm() const {
  // @@protoc_insertion_point(field_get:sro.character.EditCharacterRequest.realm)
  return _internal_realm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EditCharacterRequest::set_realm(Arg_&& arg,
                                                     Args_... args) {
  if (optional_realm_case() != kRealm) {
    clear_optional_realm();

    set_has_realm();
    _impl_.optional_realm_.realm_.InitDefault();
  }
  _impl_.optional_realm_.realm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.EditCharacterRequest.realm)
}
inline std::string* EditCharacterRequest::mutable_realm() {
  std::string* _s = _internal_mutable_realm();
  // @@protoc_insertion_point(field_mutable:sro.character.EditCharacterRequest.realm)
  return _s;
}
inline const std::string& EditCharacterRequest::_internal_realm() const {
  if (optional_realm_case() != kRealm) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.optional_realm_.realm_.Get();
}
inline void EditCharacterRequest::_internal_set_realm(const std::string& value) {
  if (optional_realm_case() != kRealm) {
    clear_optional_realm();

    set_has_realm();
    _impl_.optional_realm_.realm_.InitDefault();
  }


  _impl_.optional_realm_.realm_.Set(value, GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::_internal_mutable_realm() {
  if (optional_realm_case() != kRealm) {
    clear_optional_realm();

    set_has_realm();
    _impl_.optional_realm_.realm_.InitDefault();
  }
  return _impl_.optional_realm_.realm_.Mutable( GetArenaForAllocation());
}
inline std::string* EditCharacterRequest::release_realm() {
  // @@protoc_insertion_point(field_release:sro.character.EditCharacterRequest.realm)
  if (optional_realm_case() != kRealm) {
    return nullptr;
  }
  clear_has_optional_realm();
  return _impl_.optional_realm_.realm_.Release();
}
inline void EditCharacterRequest::set_allocated_realm(std::string* value) {
  if (has_optional_realm()) {
    clear_optional_realm();
  }
  if (value != nullptr) {
    set_has_realm();
    _impl_.optional_realm_.realm_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:sro.character.EditCharacterRequest.realm)
}

// uint64 play_time = 7;
inline bool EditCharacterRequest::has_play_time() const {
  return optional_play_time_case() == kPlayTime;
}
inline void EditCharacterRequest::set_has_play_time() {
  _impl_._oneof_case_[4] = kPlayTime;
}
inline void EditCharacterRequest::clear_play_time() {
  if (optional_play_time_case() == kPlayTime) {
    _impl_.optional_play_time_.play_time_ = ::uint64_t{0u};
    clear_has_optional_play_time();
  }
}
inline ::uint64_t EditCharacterRequest::play_time() const {
  // @@protoc_insertion_point(field_get:sro.character.EditCharacterRequest.play_time)
  return _internal_play_time();
}
inline void EditCharacterRequest::set_play_time(::uint64_t value) {
  _internal_set_play_time(value);
  // @@protoc_insertion_point(field_set:sro.character.EditCharacterRequest.play_time)
}
inline ::uint64_t EditCharacterRequest::_internal_play_time() const {
  if (optional_play_time_case() == kPlayTime) {
    return _impl_.optional_play_time_.play_time_;
  }
  return ::uint64_t{0u};
}
inline void EditCharacterRequest::_internal_set_play_time(::uint64_t value) {
  if (optional_play_time_case() != kPlayTime) {
    clear_optional_play_time();
    set_has_play_time();
  }
  _impl_.optional_play_time_.play_time_ = value;
}

// .sro.Location location = 8;
inline bool EditCharacterRequest::has_location() const {
  return optional_location_case() == kLocation;
}
inline bool EditCharacterRequest::_internal_has_location() const {
  return optional_location_case() == kLocation;
}
inline void EditCharacterRequest::set_has_location() {
  _impl_._oneof_case_[5] = kLocation;
}
inline ::sro::Location* EditCharacterRequest::release_location() {
  // @@protoc_insertion_point(field_release:sro.character.EditCharacterRequest.location)
  if (optional_location_case() == kLocation) {
    clear_has_optional_location();
    ::sro::Location* temp = _impl_.optional_location_.location_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.optional_location_.location_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sro::Location& EditCharacterRequest::_internal_location() const {
  return optional_location_case() == kLocation
      ? *_impl_.optional_location_.location_
      : reinterpret_cast<::sro::Location&>(::sro::_Location_default_instance_);
}
inline const ::sro::Location& EditCharacterRequest::location() const {
  // @@protoc_insertion_point(field_get:sro.character.EditCharacterRequest.location)
  return _internal_location();
}
inline ::sro::Location* EditCharacterRequest::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sro.character.EditCharacterRequest.location)
  if (optional_location_case() == kLocation) {
    clear_has_optional_location();
    ::sro::Location* temp = _impl_.optional_location_.location_;
    _impl_.optional_location_.location_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCharacterRequest::unsafe_arena_set_allocated_location(::sro::Location* location) {
  clear_optional_location();
  if (location) {
    set_has_location();
    _impl_.optional_location_.location_ = location;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.character.EditCharacterRequest.location)
}
inline ::sro::Location* EditCharacterRequest::_internal_mutable_location() {
  if (optional_location_case() != kLocation) {
    clear_optional_location();
    set_has_location();
    _impl_.optional_location_.location_ = CreateMaybeMessage< ::sro::Location >(GetArenaForAllocation());
  }
  return _impl_.optional_location_.location_;
}
inline ::sro::Location* EditCharacterRequest::mutable_location() {
  ::sro::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:sro.character.EditCharacterRequest.location)
  return _msg;
}

// .sro.gamebackend.DimensionTarget dimension = 9;
inline bool EditCharacterRequest::has_dimension() const {
  return optional_dimension_case() == kDimension;
}
inline bool EditCharacterRequest::_internal_has_dimension() const {
  return optional_dimension_case() == kDimension;
}
inline void EditCharacterRequest::set_has_dimension() {
  _impl_._oneof_case_[6] = kDimension;
}
inline ::sro::gamebackend::DimensionTarget* EditCharacterRequest::release_dimension() {
  // @@protoc_insertion_point(field_release:sro.character.EditCharacterRequest.dimension)
  if (optional_dimension_case() == kDimension) {
    clear_has_optional_dimension();
    ::sro::gamebackend::DimensionTarget* temp = _impl_.optional_dimension_.dimension_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.optional_dimension_.dimension_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sro::gamebackend::DimensionTarget& EditCharacterRequest::_internal_dimension() const {
  return optional_dimension_case() == kDimension
      ? *_impl_.optional_dimension_.dimension_
      : reinterpret_cast<::sro::gamebackend::DimensionTarget&>(::sro::gamebackend::_DimensionTarget_default_instance_);
}
inline const ::sro::gamebackend::DimensionTarget& EditCharacterRequest::dimension() const {
  // @@protoc_insertion_point(field_get:sro.character.EditCharacterRequest.dimension)
  return _internal_dimension();
}
inline ::sro::gamebackend::DimensionTarget* EditCharacterRequest::unsafe_arena_release_dimension() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sro.character.EditCharacterRequest.dimension)
  if (optional_dimension_case() == kDimension) {
    clear_has_optional_dimension();
    ::sro::gamebackend::DimensionTarget* temp = _impl_.optional_dimension_.dimension_;
    _impl_.optional_dimension_.dimension_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCharacterRequest::unsafe_arena_set_allocated_dimension(::sro::gamebackend::DimensionTarget* dimension) {
  clear_optional_dimension();
  if (dimension) {
    set_has_dimension();
    _impl_.optional_dimension_.dimension_ = dimension;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.character.EditCharacterRequest.dimension)
}
inline ::sro::gamebackend::DimensionTarget* EditCharacterRequest::_internal_mutable_dimension() {
  if (optional_dimension_case() != kDimension) {
    clear_optional_dimension();
    set_has_dimension();
    _impl_.optional_dimension_.dimension_ = CreateMaybeMessage< ::sro::gamebackend::DimensionTarget >(GetArenaForAllocation());
  }
  return _impl_.optional_dimension_.dimension_;
}
inline ::sro::gamebackend::DimensionTarget* EditCharacterRequest::mutable_dimension() {
  ::sro::gamebackend::DimensionTarget* _msg = _internal_mutable_dimension();
  // @@protoc_insertion_point(field_mutable:sro.character.EditCharacterRequest.dimension)
  return _msg;
}

inline bool EditCharacterRequest::has_optional_owner_id() const {
  return optional_owner_id_case() != OPTIONAL_OWNER_ID_NOT_SET;
}
inline void EditCharacterRequest::clear_has_optional_owner_id() {
  _impl_._oneof_case_[0] = OPTIONAL_OWNER_ID_NOT_SET;
}
inline bool EditCharacterRequest::has_optional_new_name() const {
  return optional_new_name_case() != OPTIONAL_NEW_NAME_NOT_SET;
}
inline void EditCharacterRequest::clear_has_optional_new_name() {
  _impl_._oneof_case_[1] = OPTIONAL_NEW_NAME_NOT_SET;
}
inline bool EditCharacterRequest::has_optional_gender() const {
  return optional_gender_case() != OPTIONAL_GENDER_NOT_SET;
}
inline void EditCharacterRequest::clear_has_optional_gender() {
  _impl_._oneof_case_[2] = OPTIONAL_GENDER_NOT_SET;
}
inline bool EditCharacterRequest::has_optional_realm() const {
  return optional_realm_case() != OPTIONAL_REALM_NOT_SET;
}
inline void EditCharacterRequest::clear_has_optional_realm() {
  _impl_._oneof_case_[3] = OPTIONAL_REALM_NOT_SET;
}
inline bool EditCharacterRequest::has_optional_play_time() const {
  return optional_play_time_case() != OPTIONAL_PLAY_TIME_NOT_SET;
}
inline void EditCharacterRequest::clear_has_optional_play_time() {
  _impl_._oneof_case_[4] = OPTIONAL_PLAY_TIME_NOT_SET;
}
inline bool EditCharacterRequest::has_optional_location() const {
  return optional_location_case() != OPTIONAL_LOCATION_NOT_SET;
}
inline void EditCharacterRequest::clear_has_optional_location() {
  _impl_._oneof_case_[5] = OPTIONAL_LOCATION_NOT_SET;
}
inline bool EditCharacterRequest::has_optional_dimension() const {
  return optional_dimension_case() != OPTIONAL_DIMENSION_NOT_SET;
}
inline void EditCharacterRequest::clear_has_optional_dimension() {
  _impl_._oneof_case_[6] = OPTIONAL_DIMENSION_NOT_SET;
}
inline EditCharacterRequest::OptionalOwnerIdCase EditCharacterRequest::optional_owner_id_case() const {
  return EditCharacterRequest::OptionalOwnerIdCase(_impl_._oneof_case_[0]);
}
inline EditCharacterRequest::OptionalNewNameCase EditCharacterRequest::optional_new_name_case() const {
  return EditCharacterRequest::OptionalNewNameCase(_impl_._oneof_case_[1]);
}
inline EditCharacterRequest::OptionalGenderCase EditCharacterRequest::optional_gender_case() const {
  return EditCharacterRequest::OptionalGenderCase(_impl_._oneof_case_[2]);
}
inline EditCharacterRequest::OptionalRealmCase EditCharacterRequest::optional_realm_case() const {
  return EditCharacterRequest::OptionalRealmCase(_impl_._oneof_case_[3]);
}
inline EditCharacterRequest::OptionalPlayTimeCase EditCharacterRequest::optional_play_time_case() const {
  return EditCharacterRequest::OptionalPlayTimeCase(_impl_._oneof_case_[4]);
}
inline EditCharacterRequest::OptionalLocationCase EditCharacterRequest::optional_location_case() const {
  return EditCharacterRequest::OptionalLocationCase(_impl_._oneof_case_[5]);
}
inline EditCharacterRequest::OptionalDimensionCase EditCharacterRequest::optional_dimension_case() const {
  return EditCharacterRequest::OptionalDimensionCase(_impl_._oneof_case_[6]);
}
// -------------------------------------------------------------------

// CharacterDetails

// uint64 id = 1;
inline void CharacterDetails::clear_id() {
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t CharacterDetails::id() const {
  // @@protoc_insertion_point(field_get:sro.character.CharacterDetails.id)
  return _internal_id();
}
inline void CharacterDetails::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sro.character.CharacterDetails.id)
}
inline ::uint64_t CharacterDetails::_internal_id() const {
  return _impl_.id_;
}
inline void CharacterDetails::_internal_set_id(::uint64_t value) {
  ;
  _impl_.id_ = value;
}

// string owner = 2;
inline void CharacterDetails::clear_owner() {
  _impl_.owner_.ClearToEmpty();
}
inline const std::string& CharacterDetails::owner() const {
  // @@protoc_insertion_point(field_get:sro.character.CharacterDetails.owner)
  return _internal_owner();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CharacterDetails::set_owner(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.owner_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.CharacterDetails.owner)
}
inline std::string* CharacterDetails::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:sro.character.CharacterDetails.owner)
  return _s;
}
inline const std::string& CharacterDetails::_internal_owner() const {
  return _impl_.owner_.Get();
}
inline void CharacterDetails::_internal_set_owner(const std::string& value) {
  ;


  _impl_.owner_.Set(value, GetArenaForAllocation());
}
inline std::string* CharacterDetails::_internal_mutable_owner() {
  ;
  return _impl_.owner_.Mutable( GetArenaForAllocation());
}
inline std::string* CharacterDetails::release_owner() {
  // @@protoc_insertion_point(field_release:sro.character.CharacterDetails.owner)
  return _impl_.owner_.Release();
}
inline void CharacterDetails::set_allocated_owner(std::string* value) {
  _impl_.owner_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owner_.IsDefault()) {
          _impl_.owner_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.character.CharacterDetails.owner)
}

// string name = 3;
inline void CharacterDetails::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CharacterDetails::name() const {
  // @@protoc_insertion_point(field_get:sro.character.CharacterDetails.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CharacterDetails::set_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.CharacterDetails.name)
}
inline std::string* CharacterDetails::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sro.character.CharacterDetails.name)
  return _s;
}
inline const std::string& CharacterDetails::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CharacterDetails::_internal_set_name(const std::string& value) {
  ;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CharacterDetails::_internal_mutable_name() {
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* CharacterDetails::release_name() {
  // @@protoc_insertion_point(field_release:sro.character.CharacterDetails.name)
  return _impl_.name_.Release();
}
inline void CharacterDetails::set_allocated_name(std::string* value) {
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.character.CharacterDetails.name)
}

// string gender = 4;
inline void CharacterDetails::clear_gender() {
  _impl_.gender_.ClearToEmpty();
}
inline const std::string& CharacterDetails::gender() const {
  // @@protoc_insertion_point(field_get:sro.character.CharacterDetails.gender)
  return _internal_gender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CharacterDetails::set_gender(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.gender_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.CharacterDetails.gender)
}
inline std::string* CharacterDetails::mutable_gender() {
  std::string* _s = _internal_mutable_gender();
  // @@protoc_insertion_point(field_mutable:sro.character.CharacterDetails.gender)
  return _s;
}
inline const std::string& CharacterDetails::_internal_gender() const {
  return _impl_.gender_.Get();
}
inline void CharacterDetails::_internal_set_gender(const std::string& value) {
  ;


  _impl_.gender_.Set(value, GetArenaForAllocation());
}
inline std::string* CharacterDetails::_internal_mutable_gender() {
  ;
  return _impl_.gender_.Mutable( GetArenaForAllocation());
}
inline std::string* CharacterDetails::release_gender() {
  // @@protoc_insertion_point(field_release:sro.character.CharacterDetails.gender)
  return _impl_.gender_.Release();
}
inline void CharacterDetails::set_allocated_gender(std::string* value) {
  _impl_.gender_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gender_.IsDefault()) {
          _impl_.gender_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.character.CharacterDetails.gender)
}

// string realm = 5;
inline void CharacterDetails::clear_realm() {
  _impl_.realm_.ClearToEmpty();
}
inline const std::string& CharacterDetails::realm() const {
  // @@protoc_insertion_point(field_get:sro.character.CharacterDetails.realm)
  return _internal_realm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CharacterDetails::set_realm(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.realm_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.CharacterDetails.realm)
}
inline std::string* CharacterDetails::mutable_realm() {
  std::string* _s = _internal_mutable_realm();
  // @@protoc_insertion_point(field_mutable:sro.character.CharacterDetails.realm)
  return _s;
}
inline const std::string& CharacterDetails::_internal_realm() const {
  return _impl_.realm_.Get();
}
inline void CharacterDetails::_internal_set_realm(const std::string& value) {
  ;


  _impl_.realm_.Set(value, GetArenaForAllocation());
}
inline std::string* CharacterDetails::_internal_mutable_realm() {
  ;
  return _impl_.realm_.Mutable( GetArenaForAllocation());
}
inline std::string* CharacterDetails::release_realm() {
  // @@protoc_insertion_point(field_release:sro.character.CharacterDetails.realm)
  return _impl_.realm_.Release();
}
inline void CharacterDetails::set_allocated_realm(std::string* value) {
  _impl_.realm_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.realm_.IsDefault()) {
          _impl_.realm_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.character.CharacterDetails.realm)
}

// uint64 play_time = 6;
inline void CharacterDetails::clear_play_time() {
  _impl_.play_time_ = ::uint64_t{0u};
}
inline ::uint64_t CharacterDetails::play_time() const {
  // @@protoc_insertion_point(field_get:sro.character.CharacterDetails.play_time)
  return _internal_play_time();
}
inline void CharacterDetails::set_play_time(::uint64_t value) {
  _internal_set_play_time(value);
  // @@protoc_insertion_point(field_set:sro.character.CharacterDetails.play_time)
}
inline ::uint64_t CharacterDetails::_internal_play_time() const {
  return _impl_.play_time_;
}
inline void CharacterDetails::_internal_set_play_time(::uint64_t value) {
  ;
  _impl_.play_time_ = value;
}

// .sro.Location location = 8;
inline bool CharacterDetails::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline const ::sro::Location& CharacterDetails::_internal_location() const {
  const ::sro::Location* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::sro::Location&>(
      ::sro::_Location_default_instance_);
}
inline const ::sro::Location& CharacterDetails::location() const {
  // @@protoc_insertion_point(field_get:sro.character.CharacterDetails.location)
  return _internal_location();
}
inline void CharacterDetails::unsafe_arena_set_allocated_location(
    ::sro::Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.character.CharacterDetails.location)
}
inline ::sro::Location* CharacterDetails::release_location() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sro::Location* CharacterDetails::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:sro.character.CharacterDetails.location)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::Location* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::sro::Location* CharacterDetails::_internal_mutable_location() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::sro::Location>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::sro::Location* CharacterDetails::mutable_location() {
  ::sro::Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:sro.character.CharacterDetails.location)
  return _msg;
}
inline void CharacterDetails::set_allocated_location(::sro::Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location));
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:sro.character.CharacterDetails.location)
}

// string dimension = 9;
inline void CharacterDetails::clear_dimension() {
  _impl_.dimension_.ClearToEmpty();
}
inline const std::string& CharacterDetails::dimension() const {
  // @@protoc_insertion_point(field_get:sro.character.CharacterDetails.dimension)
  return _internal_dimension();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CharacterDetails::set_dimension(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.dimension_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.CharacterDetails.dimension)
}
inline std::string* CharacterDetails::mutable_dimension() {
  std::string* _s = _internal_mutable_dimension();
  // @@protoc_insertion_point(field_mutable:sro.character.CharacterDetails.dimension)
  return _s;
}
inline const std::string& CharacterDetails::_internal_dimension() const {
  return _impl_.dimension_.Get();
}
inline void CharacterDetails::_internal_set_dimension(const std::string& value) {
  ;


  _impl_.dimension_.Set(value, GetArenaForAllocation());
}
inline std::string* CharacterDetails::_internal_mutable_dimension() {
  ;
  return _impl_.dimension_.Mutable( GetArenaForAllocation());
}
inline std::string* CharacterDetails::release_dimension() {
  // @@protoc_insertion_point(field_release:sro.character.CharacterDetails.dimension)
  return _impl_.dimension_.Release();
}
inline void CharacterDetails::set_allocated_dimension(std::string* value) {
  _impl_.dimension_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.dimension_.IsDefault()) {
          _impl_.dimension_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.character.CharacterDetails.dimension)
}

// -------------------------------------------------------------------

// CharactersDetails

// repeated .sro.character.CharacterDetails characters = 1;
inline int CharactersDetails::_internal_characters_size() const {
  return _impl_.characters_.size();
}
inline int CharactersDetails::characters_size() const {
  return _internal_characters_size();
}
inline void CharactersDetails::clear_characters() {
  _internal_mutable_characters()->Clear();
}
inline ::sro::character::CharacterDetails* CharactersDetails::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:sro.character.CharactersDetails.characters)
  return _internal_mutable_characters()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::CharacterDetails >*
CharactersDetails::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:sro.character.CharactersDetails.characters)
  return _internal_mutable_characters();
}
inline const ::sro::character::CharacterDetails& CharactersDetails::_internal_characters(int index) const {
  return _internal_characters().Get(index);
}
inline const ::sro::character::CharacterDetails& CharactersDetails::characters(int index) const {
  // @@protoc_insertion_point(field_get:sro.character.CharactersDetails.characters)
  return _internal_characters(index);
}
inline ::sro::character::CharacterDetails* CharactersDetails::_internal_add_characters() {
  return _internal_mutable_characters()->Add();
}
inline ::sro::character::CharacterDetails* CharactersDetails::add_characters() {
  ::sro::character::CharacterDetails* _add = _internal_add_characters();
  // @@protoc_insertion_point(field_add:sro.character.CharactersDetails.characters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::CharacterDetails >&
CharactersDetails::characters() const {
  // @@protoc_insertion_point(field_list:sro.character.CharactersDetails.characters)
  return _internal_characters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::CharacterDetails>&
CharactersDetails::_internal_characters() const {
  return _impl_.characters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::CharacterDetails>*
CharactersDetails::_internal_mutable_characters() {
  return &_impl_.characters_;
}

// -------------------------------------------------------------------

// InventoryItem

// string id = 1;
inline void InventoryItem::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& InventoryItem::id() const {
  // @@protoc_insertion_point(field_get:sro.character.InventoryItem.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InventoryItem::set_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sro.character.InventoryItem.id)
}
inline std::string* InventoryItem::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sro.character.InventoryItem.id)
  return _s;
}
inline const std::string& InventoryItem::_internal_id() const {
  return _impl_.id_.Get();
}
inline void InventoryItem::_internal_set_id(const std::string& value) {
  ;


  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* InventoryItem::_internal_mutable_id() {
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* InventoryItem::release_id() {
  // @@protoc_insertion_point(field_release:sro.character.InventoryItem.id)
  return _impl_.id_.Release();
}
inline void InventoryItem::set_allocated_id(std::string* value) {
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sro.character.InventoryItem.id)
}

// uint32 slot = 2;
inline void InventoryItem::clear_slot() {
  _impl_.slot_ = 0u;
}
inline ::uint32_t InventoryItem::slot() const {
  // @@protoc_insertion_point(field_get:sro.character.InventoryItem.slot)
  return _internal_slot();
}
inline void InventoryItem::set_slot(::uint32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:sro.character.InventoryItem.slot)
}
inline ::uint32_t InventoryItem::_internal_slot() const {
  return _impl_.slot_;
}
inline void InventoryItem::_internal_set_slot(::uint32_t value) {
  ;
  _impl_.slot_ = value;
}

// uint64 quantity = 3;
inline void InventoryItem::clear_quantity() {
  _impl_.quantity_ = ::uint64_t{0u};
}
inline ::uint64_t InventoryItem::quantity() const {
  // @@protoc_insertion_point(field_get:sro.character.InventoryItem.quantity)
  return _internal_quantity();
}
inline void InventoryItem::set_quantity(::uint64_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:sro.character.InventoryItem.quantity)
}
inline ::uint64_t InventoryItem::_internal_quantity() const {
  return _impl_.quantity_;
}
inline void InventoryItem::_internal_set_quantity(::uint64_t value) {
  ;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// Inventory

// repeated .sro.character.InventoryItem inventory_items = 1;
inline int Inventory::_internal_inventory_items_size() const {
  return _impl_.inventory_items_.size();
}
inline int Inventory::inventory_items_size() const {
  return _internal_inventory_items_size();
}
inline void Inventory::clear_inventory_items() {
  _internal_mutable_inventory_items()->Clear();
}
inline ::sro::character::InventoryItem* Inventory::mutable_inventory_items(int index) {
  // @@protoc_insertion_point(field_mutable:sro.character.Inventory.inventory_items)
  return _internal_mutable_inventory_items()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >*
Inventory::mutable_inventory_items() {
  // @@protoc_insertion_point(field_mutable_list:sro.character.Inventory.inventory_items)
  return _internal_mutable_inventory_items();
}
inline const ::sro::character::InventoryItem& Inventory::_internal_inventory_items(int index) const {
  return _internal_inventory_items().Get(index);
}
inline const ::sro::character::InventoryItem& Inventory::inventory_items(int index) const {
  // @@protoc_insertion_point(field_get:sro.character.Inventory.inventory_items)
  return _internal_inventory_items(index);
}
inline ::sro::character::InventoryItem* Inventory::_internal_add_inventory_items() {
  return _internal_mutable_inventory_items()->Add();
}
inline ::sro::character::InventoryItem* Inventory::add_inventory_items() {
  ::sro::character::InventoryItem* _add = _internal_add_inventory_items();
  // @@protoc_insertion_point(field_add:sro.character.Inventory.inventory_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >&
Inventory::inventory_items() const {
  // @@protoc_insertion_point(field_list:sro.character.Inventory.inventory_items)
  return _internal_inventory_items();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>&
Inventory::_internal_inventory_items() const {
  return _impl_.inventory_items_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>*
Inventory::_internal_mutable_inventory_items() {
  return &_impl_.inventory_items_;
}

// repeated .sro.character.InventoryItem bank_items = 2;
inline int Inventory::_internal_bank_items_size() const {
  return _impl_.bank_items_.size();
}
inline int Inventory::bank_items_size() const {
  return _internal_bank_items_size();
}
inline void Inventory::clear_bank_items() {
  _internal_mutable_bank_items()->Clear();
}
inline ::sro::character::InventoryItem* Inventory::mutable_bank_items(int index) {
  // @@protoc_insertion_point(field_mutable:sro.character.Inventory.bank_items)
  return _internal_mutable_bank_items()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >*
Inventory::mutable_bank_items() {
  // @@protoc_insertion_point(field_mutable_list:sro.character.Inventory.bank_items)
  return _internal_mutable_bank_items();
}
inline const ::sro::character::InventoryItem& Inventory::_internal_bank_items(int index) const {
  return _internal_bank_items().Get(index);
}
inline const ::sro::character::InventoryItem& Inventory::bank_items(int index) const {
  // @@protoc_insertion_point(field_get:sro.character.Inventory.bank_items)
  return _internal_bank_items(index);
}
inline ::sro::character::InventoryItem* Inventory::_internal_add_bank_items() {
  return _internal_mutable_bank_items()->Add();
}
inline ::sro::character::InventoryItem* Inventory::add_bank_items() {
  ::sro::character::InventoryItem* _add = _internal_add_bank_items();
  // @@protoc_insertion_point(field_add:sro.character.Inventory.bank_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >&
Inventory::bank_items() const {
  // @@protoc_insertion_point(field_list:sro.character.Inventory.bank_items)
  return _internal_bank_items();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>&
Inventory::_internal_bank_items() const {
  return _impl_.bank_items_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>*
Inventory::_internal_mutable_bank_items() {
  return &_impl_.bank_items_;
}

// -------------------------------------------------------------------

// UpdateInventoryRequest

// .sro.character.CharacterTarget target = 1;
inline bool UpdateInventoryRequest::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline void UpdateInventoryRequest::clear_target() {
  if (_impl_.target_ != nullptr) _impl_.target_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sro::character::CharacterTarget& UpdateInventoryRequest::_internal_target() const {
  const ::sro::character::CharacterTarget* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::sro::character::CharacterTarget&>(
      ::sro::character::_CharacterTarget_default_instance_);
}
inline const ::sro::character::CharacterTarget& UpdateInventoryRequest::target() const {
  // @@protoc_insertion_point(field_get:sro.character.UpdateInventoryRequest.target)
  return _internal_target();
}
inline void UpdateInventoryRequest::unsafe_arena_set_allocated_target(
    ::sro::character::CharacterTarget* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sro.character.UpdateInventoryRequest.target)
}
inline ::sro::character::CharacterTarget* UpdateInventoryRequest::release_target() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::character::CharacterTarget* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sro::character::CharacterTarget* UpdateInventoryRequest::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:sro.character.UpdateInventoryRequest.target)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sro::character::CharacterTarget* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::sro::character::CharacterTarget* UpdateInventoryRequest::_internal_mutable_target() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::sro::character::CharacterTarget>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::sro::character::CharacterTarget* UpdateInventoryRequest::mutable_target() {
  ::sro::character::CharacterTarget* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:sro.character.UpdateInventoryRequest.target)
  return _msg;
}
inline void UpdateInventoryRequest::set_allocated_target(::sro::character::CharacterTarget* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:sro.character.UpdateInventoryRequest.target)
}

// repeated .sro.character.InventoryItem inventory_items = 2;
inline int UpdateInventoryRequest::_internal_inventory_items_size() const {
  return _impl_.inventory_items_.size();
}
inline int UpdateInventoryRequest::inventory_items_size() const {
  return _internal_inventory_items_size();
}
inline void UpdateInventoryRequest::clear_inventory_items() {
  _internal_mutable_inventory_items()->Clear();
}
inline ::sro::character::InventoryItem* UpdateInventoryRequest::mutable_inventory_items(int index) {
  // @@protoc_insertion_point(field_mutable:sro.character.UpdateInventoryRequest.inventory_items)
  return _internal_mutable_inventory_items()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >*
UpdateInventoryRequest::mutable_inventory_items() {
  // @@protoc_insertion_point(field_mutable_list:sro.character.UpdateInventoryRequest.inventory_items)
  return _internal_mutable_inventory_items();
}
inline const ::sro::character::InventoryItem& UpdateInventoryRequest::_internal_inventory_items(int index) const {
  return _internal_inventory_items().Get(index);
}
inline const ::sro::character::InventoryItem& UpdateInventoryRequest::inventory_items(int index) const {
  // @@protoc_insertion_point(field_get:sro.character.UpdateInventoryRequest.inventory_items)
  return _internal_inventory_items(index);
}
inline ::sro::character::InventoryItem* UpdateInventoryRequest::_internal_add_inventory_items() {
  return _internal_mutable_inventory_items()->Add();
}
inline ::sro::character::InventoryItem* UpdateInventoryRequest::add_inventory_items() {
  ::sro::character::InventoryItem* _add = _internal_add_inventory_items();
  // @@protoc_insertion_point(field_add:sro.character.UpdateInventoryRequest.inventory_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >&
UpdateInventoryRequest::inventory_items() const {
  // @@protoc_insertion_point(field_list:sro.character.UpdateInventoryRequest.inventory_items)
  return _internal_inventory_items();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>&
UpdateInventoryRequest::_internal_inventory_items() const {
  return _impl_.inventory_items_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>*
UpdateInventoryRequest::_internal_mutable_inventory_items() {
  return &_impl_.inventory_items_;
}

// repeated .sro.character.InventoryItem bank_items = 3;
inline int UpdateInventoryRequest::_internal_bank_items_size() const {
  return _impl_.bank_items_.size();
}
inline int UpdateInventoryRequest::bank_items_size() const {
  return _internal_bank_items_size();
}
inline void UpdateInventoryRequest::clear_bank_items() {
  _internal_mutable_bank_items()->Clear();
}
inline ::sro::character::InventoryItem* UpdateInventoryRequest::mutable_bank_items(int index) {
  // @@protoc_insertion_point(field_mutable:sro.character.UpdateInventoryRequest.bank_items)
  return _internal_mutable_bank_items()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >*
UpdateInventoryRequest::mutable_bank_items() {
  // @@protoc_insertion_point(field_mutable_list:sro.character.UpdateInventoryRequest.bank_items)
  return _internal_mutable_bank_items();
}
inline const ::sro::character::InventoryItem& UpdateInventoryRequest::_internal_bank_items(int index) const {
  return _internal_bank_items().Get(index);
}
inline const ::sro::character::InventoryItem& UpdateInventoryRequest::bank_items(int index) const {
  // @@protoc_insertion_point(field_get:sro.character.UpdateInventoryRequest.bank_items)
  return _internal_bank_items(index);
}
inline ::sro::character::InventoryItem* UpdateInventoryRequest::_internal_add_bank_items() {
  return _internal_mutable_bank_items()->Add();
}
inline ::sro::character::InventoryItem* UpdateInventoryRequest::add_bank_items() {
  ::sro::character::InventoryItem* _add = _internal_add_bank_items();
  // @@protoc_insertion_point(field_add:sro.character.UpdateInventoryRequest.bank_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sro::character::InventoryItem >&
UpdateInventoryRequest::bank_items() const {
  // @@protoc_insertion_point(field_list:sro.character.UpdateInventoryRequest.bank_items)
  return _internal_bank_items();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>&
UpdateInventoryRequest::_internal_bank_items() const {
  return _impl_.bank_items_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sro::character::InventoryItem>*
UpdateInventoryRequest::_internal_mutable_bank_items() {
  return &_impl_.bank_items_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace character
}  // namespace sro


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_sro_2fcharacter_2fcharacter_2eproto_2epb_2eh
